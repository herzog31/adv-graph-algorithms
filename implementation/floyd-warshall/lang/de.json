{ 
  "name": "de",
  "fields" : {
    "algorithm_btn_prev": "Zurück",
    "algorithm_btn_next": "Nächster Schritt",
    "algorithm_btn_frwd": "Vorspulen",
    "algorithm_btn_paus": "Pause",
    "algorithm_msg_finish": "Was nun?",
    "algorithm_msg_test": "Forschungsaufgaben ausprobieren:",
    "algorithm_btn_more": "Beschreibung des Algorithmus lesen",
    "algorithm_btn_exe1": "Wie würde der Algorithmus entscheiden?",
    "algorithm_btn_exe2": "Welche Kosten haben die Kanten?",
    "algorithm_status1": "Kosten des Anfangsknotens: ",
    "algorithm_status2": "Kosten der Kante: ",
    "algorithm_status3": "Kosten des Zielknotens: ",
    "algorithm_status4": "Die Kosten des Zielknotens müssen aktualisiert werden.",
    "algorithm_status5": "Die Kosten des Zielknotens können nicht aktualisiert werden.",
    "textdb_text_oneedge": "eine Kante",
    "textdb_text_edges": "Kanten",
    "textdb_text_phase": "Phase",
    "textdb_text_of": "von",
    "textdb_msg_case0_1": "Initialisierung",
    "textdb_msg_case0_2": "Der Algorithmus hat nun die erste Schätzung der Kosten für jeden Knoten eingetragen.",
    "textdb_msg_case0_3": "Die Zahl im Knoten entspricht also der ersten Schätzung der Kosten des günstigsten Weges vom Startknoten zu diesem Knoten.",
    "textdb_msg_case0_4": "Da noch keine Berechnungen durchgeführt wurden, schätzen wir zunächst unendliche Kosten für alle Knoten außer dem Startknoten selbst.",
    "textdb_msg_case1_1": "Kürzeste Wege bestimmen",
    "textdb_msg_case1_2": "Verbesserung über rote Kante prüfen",
    "textdb_msg_case1_3": "Es wird nun überprüft, ob die rote Kante einen besseren Weg zu ihrem Zielknoten ermöglicht als bisher bekannt.",
    "textdb_msg_case1_4": "Dafür wird getestet, ob die bisher bekannten Kosten des Zielknotens höher sind als die Kosten des Anfangsknotens plus der Kosten der Kante.",
    "textdb_msg_case1_5_a": "In der folgenden Phase werden die kürzesten Wege berechnet, die maximal ",
    "textdb_msg_case1_6": "Innerhalb jeder Phase werden <strong>alle Kanten</strong> überprüft, um festzustellen, ob sie eine Reduzierung der Kosten ihres Zielknotens ermöglichen.",
    "textdb_msg_case2_1": "Negative Kreise suchen",
    "textdb_msg_case2_2_a": "Bis jetzt wurden alle günstigsten Wege korrekt berechnet, die maximal ",
    "textdb_msg_case2_2_b": "benutzen.",
    "textdb_msg_case2_3_a": "Da es ",
    "textdb_msg_case2_3_b": "Knoten im Graph gibt, sind alle günstigsten Wege jetzt korrekt berechnet, falls der Graph keine negativen Kreise enthält.",
    "textdb_msg_case2_4": "Wir überprüfen den Graph also jetzt auf negative Kreise.",
    "textdb_msg_case2_5": "Überprüfe die rote Kante",
    "textdb_msg_case2_6": "Prüfe, ob die rote Kante Teil eines negativen Kreises ist.",
    "textdb_msg_case2_7": "Dafür wird getestet, ob die bisher bekannten Kosten des Zielknotens höher sind als die Kosten des Anfangsknotens plus der Kosten der Kante.",
    "textdb_msg_case2_8": "Falls dies der Fall ist, so ist die rote Kante Teil eines negativen Kreises.",
    "textdb_msg_case3_1": "Ergebnis: Negativer Kreis gefunden",
    "textdb_msg_case3_2": "Der Graph enthält einen erreichbaren negativen Kreis.",
    "textdb_msg_case3_3": "Von der Kante, die auf den negativen Kreis hingewiesen hat, sind wir über die Vorgängerkanten so lange zurückgegangen, bis wir  im Kreis gelaufen sind. Dieser negative Kreis wurde im Graphen hellrot markiert.",
    "textdb_msg_case4_1": "Ergebnis: Algorithmus erfolgreich beendet",
    "textdb_msg_case4_2": "In diesem Graph existiert kein erreichbarer negativer Kreis, und alle Kosten wurden korrekt berechnet.",
    "textdb_msg_case4_3": "Bewege den Mauszeiger auf einen Knoten, um den günstigsten Weg vom Startknoten aus zu sehen.",
    "textdb_msg_can_start": "Matrix stellt die Distanzen zwischen den Knoten dar. Jede Zelle steht für eine Pfadlänge von Knoten, dessen Label links in der Tabelle steht, zum Knoten, dessen Label oben in der Tabelle steht. Der ∞ Eintrag bedeutet, dass die Pfadlänge zwischen entsprechenden Knoten noch nicht bestimmt sind.<br/><h3>Jetzt kann der Algorithmus beginnen!</h3>",
    "textdb_msg_path_length": "Die Länge des Pfads ",
    "textdb_msg_minimal_value": " wird als Minimalwert zwischen der aktuellen Länge und der Summe von Längen ",
    "textdb_msg_calculated": " berechnet.",
    "textdb_msg_hover": "Wenn du die Maus über die Zelle bewegst, kannst du den aktuellen entsprechenden Pfad auf dem Graph sehen.",
    "textdb_msg_this_step": "In diesem Schritt wird der Weg zwischen Knoten ",
    "textdb_msg_first_step": "Der Algorithmus vergleicht schrittweise die aktuelle Pfadlängen zwischen den Knoten mit den Längen der alternativen Pfade und speichert den kleineren Wert.",
    "textdb_msg_and": " und ",
    "textdb_msg_improved": " verbessert.",
    "textdb_msg_new_path": " Der neue Pfad, der aus Teilpfaden ",
    "textdb_msg_cheaper": " besteht, ist günstiger als der aktuelle Pfad ",
    "textdb_msg_the": "Die",
    "textdb_msg_original_matrix": "Die Originalmatrix sieht so aus:",
    "textdb_msg_original_matrix_big": "Hier kannst du nur den Teil der Matrix sehen. Um die vollständige Matrix zu sehen drücke auf 'Komplette Matrix zeigen'.",
    "textdb_msg_algo_end": "Ende des Algorithmus.",
    "textdb_msg_paths_computed": "Nun wurden alle kürzesten beziehungsweise günstigsten Wege berechnet.",
    "textdb_msg_endmatrix": "Die Endmatrix sieht so aus:",
    "aufgabe1_btn_next_question": "Zur nächsten Frage vorspulen",
    "aufgabe1_btn_retry": "Nochmal versuchen",
    "aufgabe1_btn_exe2": "Probiere die zweite Forschungsaufgabe:",
    "aufgabe1_question1": "Welchen Abstandswert wird der Algorithmus für den roten Knoten eintragen?",
    "aufgabe1_answer1": "Unendlich",
    "aufgabe1_answer1_reason": "Da der Algorithmus noch keine Berechnungen durchgeführt hat, haben alle Knoten den Abstand unendlich zum Startknoten.",
    "aufgabe1_answer2_reason1": "Der Wert des Knotens wurde aktualisiert, weil über die rote Kante eine Abkürzung möglich war.",
    "aufgabe1_answer2_reason2": "Es ist",
    "aufgabe1_answer2_reason3": "Der Wert des Knotens wurde nicht verändert, weil keine Abkürzung über die rote Kante möglich war.",
    "aufgabe1_question3": "Weist die rote Kante auf einen erreichbaren negativen Kreis hin?",
    "aufgabe1_answer3_reason1": "Die Kante ist \"inkonsistent\", es ist immernoch einer Abkürzung über diese Kante möglich.",
    "aufgabe1_answer3_reason2": "Beweis:",
    "aufgabe1_answer3_reason3": "Die Kante ist \"konsistent\", es ist keine Abkürzung über diese Kante möglich.",
    "aufgabe1_msg_case3_4": "Der Kreis ist in hellrot im Graph markiert.",
    "aufgabe1_text_yes": "Ja",
    "aufgabe1_text_no": "Nein",
    "aufgabe1_text_infinity": "Unendlich",
    "aufgabe1_text_question": "Frage",
    "aufgabe1_text_results": "Ergebnisse",
    "aufgabe1_text_right_answer": "Richtige Antwort:",
    "aufgabe1_result1": "Herzlichen Glückwunsch!",
    "aufgabe1_result2": "Du hast alle Kantenkosten richtig bestimmt.",
    "aufgabe1_result3": "Forschungsaufgabe beendet",
    "aufgabe1_result4": "Anzahl Fragen:",
    "aufgabe1_result5": "Richtig beantwortet:",
    "aufgabe1_result6": "Falsch beantwortet:",
    "aufgabe2_btn_rev": "Letzte Auswahl rückgängig machen",
    "aufgabe2_whats_next": "Was möchtest du nun tun?",
    "aufgabe2_btn_more": "Weitere Informationen über den Algorithmus",
    "aufgabe2_msg_1": "Der Algorithmus hat nun die Abstandswerte aller Knoten initialisiert.",
    "aufgabe2_msg_2": "Klicke auf die Kante, die der Algorithmus als Erstes überprüfen soll.",
    "aufgabe2_msg_3": "Update der Kanten",
    "aufgabe2_msg_4": "Der Algorithmus hat nun geprüft, ob über die gewählte Kante eine Abkürzung möglich ist, und die Abstandswerte aktualisiert.",
    "aufgabe2_msg_5": "Klicke auf die Kante, die als nächstes überprüft werden soll.",
    "aufgabe2_result_1": "Da keine Kanten existieren ist die gewählte Kantenreihenfolge optimal.",
    "aufgabe2_result_2": "Die gewählte Kantenreihenfolge ist optimal, der Bellman-Ford-Algorithmus würde nach nur einer Phase bereits ein korrektes Ergebnis haben.",
    "aufgabe2_result_3": "Ergebnis",
    "aufgabe2_result_4_a": "Der Graph enthält einen erreichbaren negativen Kreis. Da dies erst am Ende erkannt werden kann, hätte der Algorithmus alle",
    "aufgabe2_result_4_b": "Phasen",
    "aufgabe2_result_4_c": "benötigt. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_result_5_a": "Mit dieser Reihenfolge würde der Algorithmus nach",
    "aufgabe2_result_5_b": "ein korrektes Ergebnis haben. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_explan1": "Welche Reihenfolgen sind optimal?",
    "aufgabe2_explan2": "Leider ist es aufwendig, die optimale Reihenfolge zu finden. Es ist genauso schwierig (also langwierig), wie der Algorithmus selbst.",
    "aufgabe2_explan3": "Wofür braucht man eine gute Sortierung?",
    "aufgabe2_explan4": "In der Praxis ist es sinnvoll, den Algorithmus abzubrechen, sobald die letzte Phase keine Veränderung mehr brachte, denn dann ist das Ergebnis optimal.",
    "aufgabe2_explan5": "Es existieren heuristische Verfahren (Näherungsverfahen), die eine möglichst gute Sortierung zu ermitteln versuchen.",
    "aufgabe2_save": "speichern"
  }
}
