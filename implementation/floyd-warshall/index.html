<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="Graphalgorithmen" />
    <meta http-equiv="X-UA-Compatible" content="IE=9">
    <meta name="author" content="Lisa Velden">
    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <script src="../library/js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="../library/js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <script src="../library/js/underscore-min.js" type="text/javascript"></script>
    <script src="js/utilities.js" type="text/javascript"></script>
    <script src="js/siteAnimation.js" type="text/javascript"></script>
    <script src="js/canvasDrawing.js" type="text/javascript"></script>
    <script src="js/graph.js" type="text/javascript"></script>
    <script src="../library/js/priorityQueueArray.js" type="text/javascript"></script>
    <script src="js/textDB.js" type="text/javascript"></script>
    <script src="js/algorithm.js" type="text/javascript"></script>
    <script src="graphs/graphs.js" type="text/javascript"></script>
    <script src="assets/questions.js" type="text/javascript"></script>
    <script src="js/aufgabe1.js" type="text/javascript"></script>
    <script src="js/aufgabe2.js" type="text/javascript"></script>
    <script src="../library/js/lang.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            showMathMenu: false,
            showMathMenuMSIE: false
        });
    </script>
    <script type="text/javascript" src="../library/js/mathjax/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=de"></script>
    <title>Der Floyd-Warshall Algorithmus</title>
</head>
<body>
    <script>
		$(document).ready(initializeSiteLayout);
        LNG.setLanguage('de');
    </script>
    <header>
        <img src="img/floyd-warshall-logo.png" id="picTitle" alt="Logo">
        <img src="img/title_floyd_warshall.png" id="figTitle" alt="Der Floyd-Warshall Algorithmus">
        <img src="img/TUMLogo_cropped.png" id="tumTitle" alt="Technische Universität München">
        <div></div>
    </header>
    <div id="tabs">
        <ul>
            <li>
                <a href="#tab_te"><span>Einführung</span></a>
            </li>
            <li>
                <a href="#tab_tg"><span>Graph erstellen</span></a>
            </li>
            <li>
                <a href="#tab_ta"><span>Algorithmus ausführen</span></a>
            </li>
            <li>
                <a href="#tab_ti"><span>Beschreibung des Algorithmus</span></a>
            </li>
            <li>
                <a href="#tab_tf1"><span>Forschungsaufgabe 1</span></a>
            </li>
            <li>
                <a href="#tab_tf2"><span>Forschungsaufgabe 2</span></a>
            </li>
            <li>
                <a href="#tab_tw"><span>Weiteres</span></a>
            </li>
        </ul>
        <div id="tab_te">
            <div id="te_div_Einfuehrungstext">
                <div id="te_div_beispiel1Container"><img id="te_img_dijkstraLR" src="img/floyd-warshall4.png" alt="Einfacher Graph mit 4 Knoten.">
                    <p>
                        Was sind die günstigsten Wege zwischen Knotenpaaren?
                    </p>
                </div>
                <h1>Kürzeste Pfade zwischen allen Paaren von Knoten</h1>
                <p>
                    Wenn man die Distanzen zwischen verschiedenen Orten berücksichtigt, zum Beispiel im Bereich Logistik, kommen die Aufgaben über die kürzeste Wege oft vor. In diesen Situationen können die Orte als die Knoten und die Kanten als Wege im Graph dargestellt werden.
                </p>
                <p>
                    Bei der Lösung vieler Aufgaben muss man die kürzeste Wege zwischen allen Paaren von Knoten eines Graphen bestimmen und deren Längen berechnen. Der Floyd-Warshall Algorithmus, der dieses Problem löst, kann auf dem beliebigen Graph ausgeführt werden, wobei es wichtig ist, dass
                    er keine negative Kreise enthält. Falls es negaive Kreise im Graph gibt, dann können die genutzt werden um beliebig kleinen (negativen) Wege zwischen einigen Knoten zu konstruieren. In diesem Fall kann der Algorithmus keinen optimalen Wert erzeugen.
                </p>
                <h2>Hier wird der Floyd-Warshall-Algorithmus vorgestellt, der günstigste Wege zwischen allen Paaren von Knoten berechnet.</h2>
                <div id ="te_div_Entscheidung">
                    <h2>Was möchtest du zuerst tun?</h2>
                    <button id="te_button_gotoDrawGraph">
                        Den Algorithmus testen!
                    </button>
                    <button id="te_button_gotoIdee">
                        Genauere Beschreibung des Algorithmus lesen
                    </button>
                </div>
            </div>
        </div>
        <div id="tab_tg">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tg_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tg_div_statusWindow" class="statusWindow">
                    <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                    <div id="tg_div_statusErklaerung">
                        <p>
                            Um einen Knoten zu erstellen, mache einen Doppelklick in das Zeichenfeld.
                        </p>
                        <p>
                            Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.
                        </p>
                        <p>
                            Das Kantengewicht kann mit einem Doppelklick auf die Kante verändert werden.
                        </p>
                        <p>
                            Ein Rechtsklick löscht Kanten und Knoten.
                        </p>
                    </div>
                    <h3>Keine Lust, selbst einen Graph zu erstellen?
                    <br>
                    </h3>
                    <h3>Nimm ein fertiges Beispiel!
                    <br>
                    </h3>
                    <select id="tg_select_GraphSelector" name="Wähle einen Graphen">
                        <option selected id="tg_selectoption_empty">Selbsterstellter Graph</option>
                        <option>Zufallsgraph</option>
                        <option>Standardbeispiel</option>
                        <option>Gitter</option>
                        <option>Großstädte Europas</option>
                    </select>
                    <p>
                        <button id="tg_button_gotoAlgorithmTab">
                            Fertig &ndash; weiter zum Algorithmus!
                        </button>
                    </p>
                </div>
            </div>
        </div>
        <div id="tab_ta">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="ta_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="ta_div_statusWindow" class="statusWindow">
                    <h2 class="">Status des Algorithmus</h2>
                    <div id="matrix-overlay" style="display: none">
                        <div id="matrix-container"></div>
                        <button id='tg_button_trol' onclick='hideMatrixPopup();' class='ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only' role='button' aria-disabled='false'>
                            <span class='ui-button-text'>Matrix verstecken</span>
                        </button>
                    </div>
                    <div id="ta_div_abspielbuttons"></div>
                    <div id="ta_div_statusTabs">
                        <ul>
                            <li>
                                <a href="#ta_div_statusErklaerung">Erklärung</a>
                            </li>
                            <li>
                                <a href="#ta_div_statusPseudocode">Pseudocode</a>
                            </li>
                        </ul>
                        <div id="ta_div_statusErklaerung">
                            <div id="ta_div_statusText"></div>
                        </div>
                        <div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                            <p class="pseudocode" id="ta_p_l1">BEGIN</p>
                            <p class="pseudocode" id="ta_p_l2"> FOR ALL v ∈ V</p>
                            <p class="pseudocode" id="ta_p_l3">  d[v][v] ← 0</p>
                            <p class="pseudocode" id="ta_p_l4"> FOR ALL (u,v) ∈ E</p>
                            <p class="pseudocode" id="ta_p_l5">  d[u][v] ← w(u,v)</p>
                            <p class="pseudocode" id="ta_p_l6"> for k from 1 to |V|</p>
                            <p class="pseudocode" id="ta_p_l7">  for i from 1 to |V|</p>
                            <p class="pseudocode" id="ta_p_l8">   for j from 1 to |V|</p>
                            <p class="pseudocode" id="ta_p_l9">    if d[i][j] > d[i][k] + d[k][j]</p>
                            <p class="pseudocode" id="ta_p_l10">     d[i][j] ← d[i][k] + d[k][j]</p>
                            <p class="pseudocode" id="ta_p_l12">    end if</p>
                            <p class="pseudocode" id="ta_p_l13">END</p>
                            <h3>Status der Variablen:</h3>
                            <table border="1" cellpadding="0" cellspacing="0" width="200px" style="border-collapse:collapse;text-align:center">
                                <tr>
                                    <td><strong>i</strong></td>
                                    <td><strong>j</strong></td>
                                    <td><strong>k</strong></td>
                                </tr>
                                <tr>
                                    <td id="ta_td_i"></td>
                                    <td id="ta_td_j"></td>
                                    <td id="ta_td_k"></td>
                                </tr>
                            </table>
                        </div>
                        <div id="ta_div_PQ">
                            <button id='tg_button_showMatrix' onclick='showMatrixPopup();' class='ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only' role='button' aria-disabled='false'>
                                <span class='ui-button-text'>Komplette Matrix zeigen</span>
                            </button>
                            <h3 id="ta_title_pq" class="pq_hidden">Warteschlange:</h3>
                        </div>
                    </div>
                </div>
            </div>
            <div id="ta_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
                <p>
                    Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.
                </p>
            </div>
            <div id="ta_div_completeMatrix" title="Komplette Matrix"></div>
        </div>
        <div id="tab_ti">
            <div id="ti_div_Einfuehrungstext">
                <div class="BeispielbildContainer">
                    <figure>
                        <img id="ti_img_beispiel2" src="img/long-path1.png" alt="Distanzmatrix" width="250"><figcaption>Der <strong>(a, e)</strong> Weg ist optimal, denn die Wege <strong>(a, c)</strong> und <strong>(c, e)</strong> sind auch optimal.</figcaption>
                    </figure>
                </div>

                <h1>Kürzeste Wege</h1>
                <p>
                    Als Beispiel könnte man das folgende Problem betrachten: es gibt 10 Städte, die miteinander durch verschiedenen Autobahnen verbunden sind. Die Aufgabe besteht darin, die minimale Distanzen zwischen allen Städten zu berechnen um die Transportkosten zu minimieren.
                </p>
                <p>
                    Gegeben ist ein Graph. Mit dem Algorithmus von Floyd-Warshall kann man kürzeste beziehungsweise günstigste Wege zwischen allen Paaren von Knoten berechnen, wenn der Graph keine negative Kreise enthält.
                    Ein Kreis in der Graphentheorie ist ein Weg in einem Graphen, bei dem Start- und Endknoten gleich sind. Ein negativer Kreis heißt ein Kreis, wo die Summe der Kantenkosten weniger als 0 ist.
                </p>
                <p>
                    Dieses Problem kann mithilfe des Floyd-Warshall Algorithmus gelöst werden. Das gesamte Netz, das bei der Aufgabe gegeben ist, kann als ein Graph dargestellt werden. Die Knoten stehen nämlich für die Städte und die Kanten können die Autobahnen repräsentieren.
                    Jede Kante bekommt eine Kost, die gleich der Entfernung zwichen Nachbarstädten in Metern oder Kilometern ist. Das Ziel ist die kürzesten Wege zwischen allen Städten zu berechnen.
                </p>

                <h1>Idee des Algorithmus</h1>
                <div class="BeispielbildContainer">
                    <figure>
                        <img id="ti_img_beispiel1" src="img/long-path.png" alt="Einfacher Graph mit 4 Knoten." width="250">
                    </figure>
                    <p>
                        Der Pfad <strong>(a, c)</strong> wurde verbessert.
                    </p>
                </div>
                <p>
                    Das Prinzip des Floyd-Warshall-Algorithmus ist <strong>dynamische Programmierung</strong>. Das heißt, alle möglichen Pfade zwischen allen Paaren von Knoten werden schrittweise verglichen, wobei nur die besten Werte gespeichert werden.
                <p>
                    Der Algorithmus geht von folgender Beobachtung aus: wenn der kürzeste Weg von <strong>u</strong> nach <strong>v</strong> durch <strong>w</strong>, dann sind die Teilpfade von u nach w und von w nach v auch minimal. Die Richtigkeit des Ergebnisses kann durch Induktion bewiesen werden. Der Floyd-Warshall Algorithmus funktioniert iterativ.

                </p>
                <p>
                    Sei G ein Graph, wo alle Knoten <strong>1</strong> bis <strong>N</strong> nummeriert sind. Beim Schritt <strong>k</strong> sei <strong>kürzesterWeg(i, j, k)</strong>
                    eine Funktion, die den kürzesten Pfad von <strong>i</strong> nach <strong>j</strong> zurückgibt, wobei nur die Knoten aus der Menge <strong>{1, 2, ... k}</strong> als Zwischenpunkte dieses Weges sein können. Im nächsten Schritt muss der Algorithmus wieder die kürzeste Pfade zwischen allen <strong>i</strong> und <strong>j</strong> aus der Knotenmenge <strong>{1, ..., k + 1}</strong> finden.
                </p>
                <p>
                    Für alle solchen Knotenpaaren gilt, dass der kürzeste Weg entweder ein Weg mit Knoten nur aus der Menge <strong>{1, ..., k}</strong> oder ein Weg, der von <strong>i</strong> nach <strong>k + 1</strong> und von <strong>k + 1</strong> nach <strong>j</strong> geht, ist. Das bedeutet, beim Schritt <strong>(k + 1)</strong> kann der Weg von <strong>i</strong> nach <strong>j</strong> entweder gleich <strong>kürzesterWeg(i, j, k)</strong> bleiben
                    oder zu <strong>kürzesterWeg(i, k + 1, k) + kürzesterWeg(k + 1, j, k)</strong> verbessert werden, je nachdem welche Länge kürzer ist. Das heißt, der Weg zwischen <strong>i</strong> und <strong>j</strong> kann gleich wie beim vorigen Schritt bleiben oder einen neuen Knoten <strong>k + 1</strong> enthalten.
                </p>
                <p>
                    Darin besteht die Idee der <strong>dynamischen Programmierung</strong>.
                    Bei jeder Iteration werden die aktuelle Pfadkosten zwischen allen Paaren von Knoten zugewiesen:<br/><br/>
                    <strong>kürzesterWeg(i, j, k) = min(kürzesterWeg(i, j, k), kürzesterWeg(i, k + 1, k) + kürzesterWeg(k + 1, j, k))</strong>
                </p>
                <p>
                    Am Ende des Ablaufs von Floyd-Warshall darf jeder Pfad beliebigen Zwischenknoten enthalten, aber der Algorithmus speichert nur den günstigsten Wert für jedes Knotenpaar. Alle Werte sind optimal, weil der Algorithmus beim jeden Schritt den Wert ändert, falls die neue Kost niedriger ist.
                </p>

                <h1>Finden von günstigsten Wegen</h1>
                <div class="BeispielbildContainer"><figure><img id="ti_img_beispiel3" src="img/fw-table.png" alt="Distanzmatrix" width="250"><figcaption>Der Weg zwischen Knoten <strong>a</strong> und <strong>d</strong> wurde verbessert.</figcaption></figure>
                </div>
                <p>
                    Um die günstigste Wege zu finden, muss der Algorithmus eine Matrix speichern, die die aktuelle Kosten zwischen allen Paaren von Knoten enthält. Die Zeilen- und Spaltenindexe stellen die Knoten dar und die Werte in der Matrix stehen für die Distanzen
                    zwischen den entsprechenden Knoten.
                </p>
                <p>
                    Angenommen der Graph ist gegeben durch seine Gewichtsmatrix <strong>W</strong>. Der Matrixeintrag <strong>W[i,j]</strong> ist das Gewicht der Kante von <strong>i</strong> nach <strong>j</strong>, falls eine solche Kante existiert. Falls es keine Kante von <strong>i</strong> nach <strong>j</strong> gibt ist <strong>W[i,j]</strong> unendlich.
                </p>
                <p>
                    Der Floyd-Warshall Algorithmus verwendet den Konzept der <strong>dynamischen Programmierung</strong> (siehe oben). Zunächst wird der Algorithmus initialisiert:
                </p>
                <ul>
                    <li>
                        Die Matrix <strong>D</strong> der kürzesten Distanzen wird mit den gleichen Längen wie die Gewichtsmatrix <strong>W</strong> initialisiert.
                    </li>
                    <li>
                        Der Algorithmus führt die Hauptschleife mit <strong>k</strong> von <strong>1</strong> bis <strong>n</strong> aus. Bei jeder Iteration in dieser Schleife versucht der Algorithmus alle <strong>(i, j)</strong> Wege durch Wege <strong>(i, k)</strong> und <strong>(k, j)</strong> verbessern.
                    </li>
                    <li>
                        Bei jeder Iteration werden die Distanzen zwischen allen Paaren von Knoten <strong>i, j</strong> betrachtet. Der Algorithmus prüft, ob <strong>(i, k)</strong> mit <strong>(k, j)</strong> kürzer als derzeitige <strong>(i, j)</strong> Länge ist.
                    </li>
                    <li>
                        Falls ob die Distanz zwischen Knoten <strong>i, k</strong> und <strong>k, j</strong> kürzer als die aktuelle Distanz ist, dann wird die Distanz zwischen Knoten <strong>i</strong> und <strong>j</strong> aktualisiert.
                    </li>
                </ul>
                <h1>Graphen mit negativen Kreisen</h1>
                <div class="BeispielbildContainer">
                    <figure>
                        <img id="ti_img_beispiel4" src="img/negative-cycle.png" alt="Negativer Kreis" width="250">
                        <figcaption>Der Weg zwischen Knoten <strong>a</strong> und <strong>e</strong> kann beliebig klein (negativ) sein.</figcaption>
                    </figure>
                </div>
                <p>
                    Ein negativer Kreis ist ein Kreis, dessen Kantengewichte eine negative Summe bilden. Wenn der Graph einen oder mehrere negative Kreise enthält, dann gibt es keinen kürzesten Weg zwischen Knoten, die den Teil des negativen Kreises bilden.
                    Der Weg zwischen diesen Knoten ist beliebig klein (negativ). Damit der Floyd-Warshall Algorithmus richtiges Ergebnis erzeugt, muss es keine negative
                    Kreise im Graphen geben.
                </p>
                <p>
                    Der Algorithmus kann genutzt werden um die negative Kreise im Graphen zu entdecken. Dafür muss der Algorithmus alle Paaren von Knoten <strong>(i, j)</strong>
                    betrachten einschließlich die, wo <strong>i = j</strong>. Wenn irgendeine Kost <strong>(i, i)</strong> nach dem Ablauf des Algorithmus in der Distanzmatrix negativ ist, dann enthält der Graph mindestens
                    einen negativen Kreis.
                </p>
                <p>
                    Im Beispiel auf dem Bild ist der Kreis <strong>(b, c, d)</strong> negativ. Das heißt, man kann unendlichmal durch diesen Kreis laufen und die Wege zwischen beliebigen Knoten aus diesem Kreis werden jeweils kürzer. Außerdem kann der Weg
                    zwischen Knoten <strong>a</strong> und <strong>e</strong> im gegebenen Beispiel beliebig klein sein, weil der Pfad zwischen diesen Knoten negativen Kreis enthalten kann.
                </p>
                <h1>Was nun?</h1>
                <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                    <h3>Einen Graph erstellen und den Algorithmus durchspielen</h3>
                    <button id="ti_button_gotoDrawGraph">
                        Graph erstellen und daran den Algorithmus testen
                    </button>
                    <button id="ti_button_gotoAlgorithm">
                        Algorithmus am fertigen Beispiel ausprobieren
                    </button>
                </div>
                <div class="Entscheidungsweg" id="ti_div_EntscheidungRight">
                    <h3>Sein Wissen an den Forschungsaufgaben testen</h3>
                    <button id="ti_button_gotoFA1">
                        Forschungsaufgabe: Welche Distanzwerte erhalten die Pfade?
                    </button>
                    <br>
                    <button id="ti_button_gotoFA2">
                        Forschungsaufgabe: Welche Kosten haben die Kanten?
                    </button>
                </div>
            </div>
        </div>

        <div id="tab_tf1">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tf1_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tf1_div_statusWindow" class="statusWindow">
                    <h2 class="">Prüfe dein Wissen: Wie würde der Algorithmus entscheiden?</h2>
                    <div id="tf1_div_abspielbuttons"></div>
                    <div id="tf1_div_statusTabs">
                        <ul>
                            <li>
                                <a href="#tf1_div_statusErklaerung">Erklärung</a>
                            </li>
                            <li>
                                <a href="#tf1_div_statusPseudocode">Pseudocode</a>
                            </li>
                        </ul>
                        <div id="tf1_div_statusErklaerung">
                            <div id="tf1_div_statusText">
                                <p>
                                    Hier kannst du den Algorithmus ausführen und Fragen dazu beantworten.
                                </p>
                                <button id="tf1_button_start">
                                    Los geht's!
                                </button>
                            </div>
                        </div>
                        <div class="PseudocodeWrapper" id="tf1_div_statusPseudocode">
                            <p class="pseudocode" id="tf1_p_l1">BEGIN</p>
                            <p class="pseudocode" id="tf1_p_l2"> for each vertex v</p>
                            <p class="pseudocode" id="tf1_p_l3">  d[v][v] ← 0</p>
                            <p class="pseudocode" id="tf1_p_l4"> for each edge (u,v)</p>
                            <p class="pseudocode" id="tf1_p_l5">  d[u][v] ← w(u,v)</p>
                            <p class="pseudocode" id="tf1_p_l6"> for k from 1 to |V|</p>
                            <p class="pseudocode" id="tf1_p_l7">  for i from 1 to |V|</p>
                            <p class="pseudocode" id="tf1_p_l8">   for j from 1 to |V|</p>
                            <p class="pseudocode" id="tf1_p_l9">    if d[i][j] > d[i][k] + d[k][j]</p>
                            <p class="pseudocode" id="tf1_p_l10">     d[i][j] ← d[i][k] + d[k][j]</p>
                            <p class="pseudocode" id="tf1_p_l12">    end if</p>
                            <p class="pseudocode" id="tf1_p_l13">END</p>
                            <h3>Status der Variablen:</h3>
                            <table border="1" cellpadding="0" cellspacing="0" width="200px" style="border-collapse:collapse;text-align:center">
                                <tr>
                                    <td><strong>i</strong></td>
                                    <td><strong>j</strong></td>
                                    <td><strong>k</strong></td>
                                </tr>
                                <tr>
                                    <td id="tf1_td_i"></td>
                                    <td id="tf1_td_j"></td>
                                    <td id="tf1_td_k"></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            <div id="tf1_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
                <p>
                    Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.
                </p>
            </div>
        </div>
        <div id="tab_tf2">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tf2_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tf2_div_statusWindow" class="statusWindow">
                    <h2 class="">Welche Kosten haben die Kanten?</h2>
                    <div id="tf2_div_statusErklaerung">
                        <p>
                            Du siehst gleich eine finale Matrix, die die günstigsten Pfadlängen zwischen allen Paaren von Knoten im gegebenen Graph darstellt. In dieser Aufgabe musst du die fehlende Kosten von Kanten bestimmen. Um die Kantenkost einzugeben, klicke doppelt auf die Kante und tippe den Wert, dann klicke "Speichern".
                        </p>
                        <h3>Entfernungen der Knoten:</h3>
                        <table id="matrix">
                        <tbody>
                          <tr>
                             <td></td>
                             <td class="node_label">a</td>
                             <td class="node_label">b</td>
                             <td class="node_label">c</td>
                             <td class="node_label">d</td>
                             <td class="node_label">e</td>
                             <td class="node_label">f</td>
                             <td class="node_label">g</td>
                             <td class="node_label">h</td>
                          </tr>
                          <tr class="table-row">
                             <td class="node_label">a</td>
                             <td>0</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                          </tr>
                          <tr class="table-row">
                             <td class="node_label">b</td>
                             <td>12</td>
                             <td>0</td>
                             <td>3</td>
                             <td>12</td>
                             <td>8</td>
                             <td>2</td>
                             <td>5</td>
                             <td>10</td>
                          </tr>
                          <tr class="table-row">
                             <td class="node_label">c</td>
                             <td>9</td>
                             <td>14</td>
                             <td>0</td>
                             <td>9</td>
                             <td>5</td>
                             <td>16</td>
                             <td>11</td>
                             <td>16</td>
                          </tr>
                          <tr class="table-row">
                             <td class="node_label">d</td>
                             <td>17</td>
                             <td>22</td>
                             <td>8</td>
                             <td>0</td>
                             <td>13</td>
                             <td>24</td>
                             <td>2</td>
                             <td>7</td>
                          </tr>
                          <tr class="table-row">
                             <td class="node_label">e</td>
                             <td>4</td>
                             <td>9</td>
                             <td>12</td>
                             <td>4</td>
                             <td>0</td>
                             <td>11</td>
                             <td>6</td>
                             <td>11</td>
                          </tr>
                          <tr class="table-row">
                             <td class="node_label">f</td>
                             <td>11</td>
                             <td>4</td>
                             <td>7</td>
                             <td>16</td>
                             <td>12</td>
                             <td>0</td>
                             <td>3</td>
                             <td>8</td>
                          </tr>
                          <tr class="table-row">
                             <td class="node_label">g</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>0</td>
                             <td>5</td>
                          </tr>
                          <tr class="table-row">
                             <td class="node_label">h</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>∞</td>
                             <td>1</td>
                             <td>0</td>
                          </tr>
                        </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div title="Forschungsaufgabe 2" class="tabIntroDialog">
                <h2> Welche Kosten haben die Kanten? </h2>
                <p>
                    Hier siehst du in einer Tabelle, welche Entfernungen die Knoten voneinander haben.
                </p>
                <p>
                    Kannst du herausfinden, welche Kosten die Kanten haben? Klicke einfach doppelt auf eine Kante im Zeichenbereich und trage die Kosten ein, die diese Kante haben muss.
                </p>
            </div>
            <div id="tf2_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
                <p>
                    Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.
                </p>
            </div>
        </div>
        <div id="tab_tw">
            <div id="tw_Accordion">
                <h3>Wie sieht der (Pseudo-)Code des Algorithmus aus?</h3>
                <div>
                    <pre><code>Eingabe: Gewichteter, ungerichteter oder gerichteter Graph G=(V,E) mit Gewichtsfunktion w,
         wobei der Graph keine negative Kreise enthält.
Ausgabe: eine Matrix D, die die kürzesten Distanzen enthält.</code></pre>
                    <hr>
                    <pre><code>
BEGIN
  FOR ALL v ∈ V
    D[v][v] ← 0
  FOR ALL (u,v) ∈ E
    D[u][v] ← w(u,v)
  FOR k from 1 to |V|
    FOR i from 1 to |V|
      FOR j from 1 to |V|
        if D[i][j] > D[i][k] + D[k][j]
          D[i][j] ← D[i][k] + D[k][j]
        end if
END</code></pre>
                </div>
                <h3>Wie schnell ist der Algorithmus?</h3>
                <div>
                    <h2>Geschwindigkeit von Algorithmen</h2>
                    <p>
                        Die Geschwindigkeit von Algorithmen wird üblicherweise in der <strong>Anzahl an Einzelschritten</strong> gemessen, die der Algorithmus bei der Ausführung benötigt.
                    </p>
                    <p>
                        Einzelschritte sind beispielsweise:
                    </p>
                    <ul>
                        <li>
                            Zuweisungen &ndash; Weise Knoten 1 den Wert 20 zu.
                        </li>
                        <li>
                            Vergleiche  &ndash; Ist 20 größer als 23?
                        </li>
                        <li>
                            Vergleich und Zuweisung  &ndash; Falls 20 größer als 15 ist, setze Variable <var>n</var> auf 20.
                        </li>
                        <li>
                            Einfache Arithmetische Operationen &ndash; Was ist 5 + 5 ?
                        </li>
                    </ul>
                    <p>
                        Da es sehr schwierig sein kann, diese Einzelschritte exakt zu zählen, möchte man nur die ungefähre <strong>Größenordnung</strong> der Anzahl Schritte wissen.
                        Man spricht auch von der <strong>Laufzeit</strong> des Algorithmus.
                        Meistens ist es besonders interessant, zu wissen, wie die Geschwindigkeit des Algorithmus von der Größe der Eingabe (hier: Anzahl Kanten und Knoten im Graph) abhängt.
                    </p>
                    <h2>Laufzeit des Floyd-Warshall Algorithmus</h2>
                    <p>
                        Angenommen der Graph besteht aus <strong>n</strong> Knoten. Der Floyd-Warshall Algorithmus vergleicht alle mögliche Pfade im Graphen zwischen jedem Paar von Knoten. Drei inliegende Schleifen enthalten eine Operation, die in konstanter Zeit ausgeführt wird.
                    </p>
                    <p>
                        Jede Schleife besteht aus n Iterationen. Daher ist die <strong>Gesamtlaufzeit des Algorithmus</strong> \(O(n^3)\) das heißt der Algorithmus läuft in kubischer Zeit.
                    </p>
                    <p>
                        Den vollständigen Beweis kann der interessierte Leser in der geeigneten Literatur nachlesen.
                    </p>
                </div>
                <h3>Berechnet der Algorithmus wirklich die kürzesten Wege?</h3>
                <div>
                    <h2>Ein Beweis durch Induktion</h2>
                    <p>Induktionshypothese: nach der Iteration <strong>p</strong> der äußeren Schleife werden die kürzesten Wege, die nur Knoten aus <strong>{1, ..., p}</strong> enthalten, gefunden.</p>
                    <p>Am Anfang, wenn noch keine Iterationen der äußeren Schleife ausgeführt wurden, enthält jeder Eintrag d[i][j] die kürzeste Distanz von i bis j mit 0 Zwischenknoten: das Gewicht der Kante (i,j).</p>
                    <p>Vor der Iteration <strong>p</strong> gilt, dass der kürzeste Pfad Q von <strong>i</strong> nach <strong>j</strong> nur die Knoten aus der Menge <strong>{1, ..., p-1}</strong> enthält.</p>
                    <p>Bei der Iteration <strong>p</strong> wird die Länge von Q mit der Länge vom neuen Pfad R verglichen. R besteht aus R1 (der Pfad von <strong>i</strong> nach <strong>p</strong> mit Zwischenknoten aus <strong>{1, ..., p-1}</strong>) und R2 (der Pfad von <strong>p</strong> nach <strong>j</strong> mit Zwischenknoten aus
                        <strong>{1, ..., p-1}</strong>). Der kürzeste Pfad zwischen Q und R wird ausgewählt.</p>
                    <p>Also der kürzeste Weg von <strong>i</strong> nach <strong>j</strong>, der nur Knoten aus <strong>{1, ..., p}</strong> enthält:</p>
                    <ul>
                        <li>
                            enthält entweder den Knoten <strong>p</strong> nicht und damit gleich dem Weg aus der vorigen Iteration ist
                        </li>
                        <li>
                            oder enthält den Knoten <strong>p</strong> und damit kann in Pfaden von <strong>i</strong> nach <strong>p</strong> und von <strong>p</strong> nach <strong>j</strong> zerlegt werden kann. Die Pfade von <strong>i</strong> nach <strong>p</strong> und von <strong>p</strong> nach <strong>j</strong> sind gleich wie in der vorigen Iteration, weil die nur Knoten aus
                            <strong>{1, ..., p-1}</strong> enthalten.
                        </li>
                    </ul>
                    <p>
                        Daher gilt: nach der Iteration <strong>p</strong> werden die kürzesten Wege, die nur Knoten aus <strong>{1, ..., p}</strong> enthalten, zwischen allen Paaren von Knoten gefunden.
                    </p>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <p class="Disclaimer">
            IDP Projekt von Aleksejs Voroncovs am Lehrstuhl M9 der Technischen Universität München. 2015 | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Disclaimer und Rechtshinweise</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">Impressum</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Anregungen</a>
        </p>
    </footer>
</body>
