  //construct matching graph
        var mg = new BipartiteGraph();
        var unodes = {};
        var vnodes = {};
        var id_map = {};
        //insert supply nodes
        for(var node in supplyNodes){
            var id = node.getNodeID();
            for (var i=0;i<-delta[id];i++){
                var tmp = mg.addNode(true);
                id_map[tmp.getNodeID()] = id;
                unodes[tmp.getNodeID()]=tmp;
            }
        }
        //insert demand nodes
        for(var node in demandNodes){
            var id = node.getNodeID();
            for (var i=0;i<delta[id];i++){
                var tmp = mg.addNode(false);
                id_map[tmp.getNodeID()] = id;
                vnodes[tmp.getNodeID()]=tmp;
            }
        }
        //insert edges
        for(var n1 in unodes){
            for(var n2 in vnodes){
                var id1 = id_map[n1.getNodeID()];
                var id2 = id_map[n2.getNodeID()];
                var dist = distance[id1][id2];
                mg.addEdge(n1,n2,-dist);
            }
        }
        //TODO
        /*
        * hier uebergebe ich den Graphen mg an die ungarische Methode
        * als rueckgabewert erwarte ich eine Menge von Kanten
        * var edges = ungarisch(mg);
        * */
        var edges = {};

        //find the original nodes and paths of the matching
        paths = {};
        for(var v in supplyNodes){
            paths[v] = [];
        }
        for(var e in edges){
            var edge = edges[e];
            var s = id_map[edge.getSourceID()];
            var t = id_map[edge.getTargetID()];
            if(delta[s]>0) {
                paths[s].push(t);
            }
            else paths[t].push(s);
        }

               //TODO
                /*
                * hier uebergebe ich den Graphen an die floyd-warshall-methode
                * ich brauche die abstandswerte und die vorgaengermatrix
                * falls moeglich brauche ich die benutzten Kanten in der Vorgaengermatrix
                * d = distance[nodeId1][nodeId2] soll diese form haben
                * edge = predecessor[nodeId1][nodeId2]
                * floydWarshall(graph,distance,predecessor);
                * */
               /* var keys = Object.keys(graph.nodes);
                var matrix = new Array(keys.length);
                var keymap = {};
                for (var i = 0; i<keys.length; i++){
                    keymap[keys[i]] = i;
                    matrix[i] = new Array(keys.length);
                }
                for (var e in graph.edges){
                    var edge = graph.edges[e];
                    matrix[keymap[edge.getSourceID()]][keymap[edge.getSourceID()]] = edge.weight;
                }*/


/*        for(var n1 in graph.nodes){
            var nodeId = graph.nodes[n1].getNodeID();
            distance[nodeId] = new Object();
            for(var n2 in graph.nodes){
                var tmpId = graph.nodes[n2].getNodeID();
                if(n1 == n2) distance[nodeId][tmpId] = 0;
                else distance[nodeId][tmpId] = Math.random()*30;
            }
        }*/

            this.isFeasible = function() {

                // check from every node
                for (var startNode in graph.nodes) {
                    var reachableVertices = [];
                    var visitedEdges = [];
                    var queue = [parseInt(startNode)];

                    while(queue.length > 0) {
                        var currentNode = parseInt(queue.shift());
                        // add current node to reachable vertices if not yet in
                        if(reachableVertices.indexOf(currentNode) === -1) reachableVertices.push(currentNode);

                        // check every neighbor
                        var outEdges = graph.nodes[currentNode].getOutEdges();
                        for(var kantenID in outEdges) {
                            // skip already used edges
                            if (visitedEdges.indexOf(kantenID) !== -1) continue;
                            // add unvisited neighbors to queue
                            if(reachableVertices.indexOf(graph.edges[kantenID].getTargetID()) === -1) queue.push(graph.edges[kantenID].getTargetID());
                            // set edge to visited
                            visitedEdges.push(kantenID);
                        }

                    }

                    // return false if not all nodes can be reached
                    if(Object.keys(graph.nodes).length !== reachableVertices.length) {
                        return false;
                    }

                }

                return true;

            };


                this.draw = function(ctx) {
                    //finde alle Kanten zwischen source und target
                    var edges = [];
                    var s = source.getOutEdges();
                    var t = target.getOutEdges();
                    for(var i in s){
                        if(s[i].getTargetID() == this.getTargetID()){
                            edges.push[s[i].getEdgeID()];
                        }
                    }
                    for(var i in t){
                        if(t[i].getTargetID() == this.getSourceID()) {
                            edges.push[t[i].getEdgeID()];
                        }
                    }
                    var card = edges.length;
                    var control = null;
                    if(card > 1){
                        //berechne den Rang der Kante (id als referenz)
                        edges.sort();
                        var rank = edges.indexOf(id.toString()) + 1;
                        //berechne den Kontrollpunkt fuer die canvas-Zeichenfunktion
                        var INTERVAL = 50;
                        var half = parseInt(card/2);
                        var a = this.getSourceCoordinates();
                        var b = this.getTargetCoordinates();
                        if(this.getSourceID() > this.getTargetID()){ //a ist immer kleiner b, vertausche falls notwendig
                            var tmp = a;
                            a = b;
                            b = tmp;
                        }
                        var c = {x: (a.x + b.x)/2 , y: (a.y + b.y)/2};
                        var ab = {x: (b.x - a.x) , y: (b.y - a.y)};
                        var norm = Math.sqrt(ab.x*ab.x+ab.y*ab.y);
                        var d = {x: -ab.y/norm, y: ab.x/norm};
                        if(rank <= card/2){
                            control = {x: c.x + (half-rank+1)*INTERVAL*d.x, y: c.y + (half-rank+1)*INTERVAL*d.y};
                            if(card%2 == 0) control = {x: control.x - INTERVAL/2*d.x, y: control.y - INTERVAL/2*d.y};
                        }
                        else if(card%2 == 1 && rank == half) control = c;
                        else{
                            rank = rank - half - card%2;
                            control = {x: c.x - rank*INTERVAL*d.x, y: c.y - rank*INTERVAL*d.y};
                            if(card%2 == 0) control = {x: control.x + INTERVAL/2*d.x, y: control.y + INTERVAL/2*d.y};
                        }
                    }
                    //draw
                    if(this.getDirected()) {
                        if(this.getLayout().dashed) CanvasDrawMethods.drawDashedArrow(ctx,this.getLayout(),this.getSourceCoordinates(),this.getTargetCoordinates(),control,this.weight/*.toString()*/, this.additionalLabel);
                        else CanvasDrawMethods.drawArrow(ctx,this.getLayout(),this.getSourceCoordinates(),this.getTargetCoordinates(),control,this.weight/*.toString()*/, this.additionalLabel);
                    }
                    else {
                        if(this.getLayout().dashed) CanvasDrawMethods.drawDashedCurve(ctx,this.getLayout(),this.getSourceCoordinates(),this.getTargetCoordinates(),control);
                        else CanvasDrawMethods.drawCurve(ctx,this.getLayout(),this.getSourceCoordinates(),this.getTargetCoordinates(),control);
                    }

                           this.findMatching();
                                  //construct new graph
                                  var new_graph = new Graph();
                                  var map_supply = {};
                                  var map_demand = {};
                                  for(var n in supplyNodes){
                                      var node = supplyNodes[n];
                                      var coord = node.getCoordinates();
                                      var newn= new_graph.addNode(coord.x,coord.y);
                                      newn.setLayoutObject(node.getLayout());
                                      newn.setLabel(node.getLabel());
                                      map_supply[newn.getNodeID()] = node.getNodeID();
                                  }
                                  for(var n in demandNodes){
                                      var node = demandNodes[n];
                                      var coord = node.getCoordinates();
                                      var newn= new_graph.addNode(coord.x,coord.y);
                                      newn.setLayoutObject(node.getLayout());
                                      newn.setLabel(node.getLabel());
                                      map_demand[newn.getNodeID()] = node.getNodeID();
                                  }
                                  this.backup_graph = this.graph;
                                  this.graph = new_graph;
                                  for(var s in map_supply){
                                      for(var d in map_demand){
                                          new_graph.addEdge(new_graph.nodes[s],new_graph.nodes[d],distance[map_supply[s]][map_demand[d]]);
                                      }
                                  }
                                  var U_POSITION = 75; //standard 75
                                  var V_POSITION = 325;//standard 325
                                  var DIFF = 80;
                                  var i =0;
                                  for(var s in map_supply){
                                      this.animateMove(this.graph.nodes[s],{x: 50 + i*DIFF, y: V_POSITION});
                                      i++;
                                  }
                                  var i =0;
                                  for(var d in map_demand){
                                      this.animateMove(this.graph.nodes[d],{x: 50 + i*DIFF, y: U_POSITION});
                                      i++;
                                  }

                                    var oldCoord = {};
                                    for(var n in graph.nodes){
                                        graph.nodes[n].setLayout('hidden',true);
                                    }
                                    for(var e in graph.edges){
                                        graph.edges[e].setLayout('hidden',true);
                                    }
                                    for(var n in supplyNodes){
                                        var node = supplyNodes[n];
                                        node.setLayout('hidden',true);
                                        oldCoord[node.getNodeID()] = node.getCoordinates();
                                    }
                                    for(var n in demandNodes){
                                        var node = demandNodes[n];
                                        node.setLayout('hidden',true);
                                        oldCoord[node.getNodeID()] = node.getCoordinates();
                                    }


                                            this.findMatching();
                                            //construct new graph
                                            var new_graph = new Graph();
                                            for(var n in supplyNodes){
                                                var node = supplyNodes[n];
                                                var newn = jQuery.extend(true,{},node);
                                                new_graph.nodes[node.getNodeID()] = newn;
                                                newn
                                            }
                                            for(var n in demandNodes){
                                                var node = demandNodes[n];
                                                var newn = jQuery.extend(true,{},node);
                                                new_graph.nodes[node.getNodeID()] = newn;
                                            }
                                            for(var s in supplyNodes){
                                                for(var d in supplyNodes){
                                                    var ids = supplyNodes[s].getNodeID();
                                                    var idd = demandNodes[d].getNodeID();
                                                    new_graph.addEdge(new_graph.nodes[ids],new_graph.nodes[idd],distance[ids][idd]);
                                                }
                                            }
                                            this.backup_graph = this.graph;
                                            this.graph = new_graph;
                                            //animation
                                            var U_POSITION = 75; //standard 75
                                            var V_POSITION = 325;//standard 325
                                            var DIFF = 80;
                                            var i =0;
                                            for(var s in supplyNodes){
                                                var id = supplyNodes[s].getNodeID();
                                                this.animateMove(this.graph.nodes[id],{x: 50 + i*DIFF, y: V_POSITION});
                                                i++;
                                            }
                                            i =0;
                                            for(var d in demandNodes){
                                                var id = demandNodes[d].getNodeID();
                                                this.animateMove(this.graph.nodes[id],{x: 50 + i*DIFF, y: U_POSITION});
                                                i++;
                                            }

        this.addPath = function(){
               var s = paths[current].s;
               var d = paths[current].d;
               var last = d;
               var edges_on_path = [];
               while(last != s){
                   var e = predecessor[s][last];
                   var node1 = graph.nodes[e.getSourceID()];
                   var node2 = graph.nodes[last];
                   var ne = graph.addEdge(node1,node2, e.weight);
                   ne.setLayout('dashed',true);
                   edges_on_path.push(ne);
                   last = e.getSourceID();
               }
               graph.nodes[s].setLabel(graph.nodes[s].getLabel() + 1);
               graph.nodes[d].setLabel(graph.nodes[d].getLabel() - 1);
               //highlight the path
               var cost = 0;
               for(var e in edges_on_path){
                   edges_on_path[e].setLayout('lineColor','blue');//highlight path
                   cost += edges_on_path[e].weight;
               }
               //unhighlight previous path
               if(new_edges.length > 0){
                   for(var i in new_edges[new_edges.length-1]){
                       var edge = new_edges[new_edges.length-1][i];
                       edge.setLayout('lineColor','black');
                   }
               }
               new_edges.push(edges_on_path);
               current++;
               statusID = ADD_PATH;
               // Erklärung im Statusfenster
               $("#ta_div_statusErklaerung").html("<h3>4. " + LNG.K('algorithm_new_paths') + "</h3>"
               + "<p>" + LNG.K('algorithm_add_path_1') + "</p>"
               + "<p>" + LNG.K('algorithm_add_path_2') + "</p>"
               + "<p>" + LNG.K('algorithm_add_path_cost') + cost + "</p>");
               if(current >= paths.length){
                   statusID = SHOW_TOUR;
                   // Erklärung im Statusfenster
                   $("#ta_div_statusErklaerung").append(
                   //+ "<p>" + LNG.K('algorithm_add_path_3') + "</p>" +
                   "<p>" + LNG.K('algorithm_balanced_1') + "</p>");
               }
           };


this.startAddingPaths = function(){
        for(var n in this.graph.nodes){
            //var node = this.graph.nodes[n];
            this.animateMove(this.graph.nodes[n],tmp.old_coord[n]);
        }
        for(var n in graph.nodes){
            if(!supplyNodes[n] && !demandNodes[n]){
                var coord = graph.nodes[n].getCoordinates();
                var node = this.graph.addNode(coord.x,coord.y);
                node.setLabel(0);
                tmp.id_map[n] = node.getNodeID();
            }
        }
        for(var e in graph.edges){
            var edge = graph.edges[e];
            var ne = this.graph.addEdge(this.graph.nodes[tmp.id_map[edge.getSourceID()]], this.graph.nodes[tmp.id_map[edge.getTargetID()]],edge.weight);
            ne.setLayout('lineWidth', global_Edgelayout.lineWidth*0.5);
        }
        statusID = ADD_PATH;
        // Erklärung im Statusfenster
        $("#ta_div_statusErklaerung").html("<h3>4. " + LNG.K('algorithm_new_paths') + "</h3>"
        + "<p>" + LNG.K('algorithm_new_paths_1') + "</p>"
        + "<p>" + LNG.K('algorithm_new_paths_2') + "</p>");
    };

        var U_POSITION = 75; //standard 75
        var V_POSITION = 325;//standard 325
        var DIFF = 80;
        var i =0;
        for(var s in map_supply){
            this.animateMove(this.graph.nodes[map_supply[s]],{x: 50 + i*DIFF, y: V_POSITION});
            i++;
        }
        var i =0;
        for(var d in map_demand){
            this.animateMove(this.graph.nodes[map_demand[d]],{x: 50 + i*DIFF, y: U_POSITION});
            i++;
        }
        tmp = {map_supply: map_supply, map_demand: map_demand, old_coord: old_coord, id_map: id_map, graph: new_graph};

        var j = 0;
        for(var n in demandNodes){
            var node = demandNodes[n];
            var coord = node.getCoordinates();
            var newn= new_graph.addNode(coord.x,coord.y);
            newn.setLayoutObject(node.getLayout());
            newn.setLabel(node.getLabel());
            id_map[node.getNodeID()] = newn.getNodeID();
            this.animateMove(this.graph.nodes[map_demand[d]],{x: 50 + i*DIFF, y: U_POSITION});
            j++;
        }
        this.graph = new_graph;
        for(var s in supplyNodes){
            for(var d in demandNodes){
                var id1 = id_map[s];
                var id2 = id_map[d];
                var e = new_graph.addEdge(new_graph.nodes[id1],new_graph.nodes[id2],distance[supplyNodes[s].getNodeID()][demandNodes[d].getNodeID()],false);
                //todo edges
            }
        }
    this.addPath = function(){
        var s = matching[current].s;
        var d = matching[current].d;
        var last = d;
        var edges_on_path = [];
        var cost = 0;
        var timerId = 0;
        var cur_graph = this.graph;
        timerId = setInterval(function () {
            if(last != s){
                var e = predecessor[s][last];
                var node1 = graph.nodes[e.getSourceID()];
                var node2 = graph.nodes[last];
                var ne = graph.addEdge(node1,node2, e.weight);
                ne.setLayout('dashed',true);
                ne.setLayout('lineColor','blue');//highlight path
                edges_on_path.push(ne);
                last = e.getSourceID();
                cost += ne.weight;
                var edge = cur_graph.addEdge(cur_graph.nodes[tmp.id_map[e.getSourceID()]], cur_graph.nodes[tmp.id_map[e.getTargetID()]],e.weight);
                edge.setLayout('dashed',true);
                edge.setLayout('lineColor','blue');//highlight path
            }
            else{
                clearInterval(timerId);
                graph.nodes[s].setLabel(graph.nodes[s].getLabel() + 1);
                graph.nodes[d].setLabel(graph.nodes[d].getLabel() - 1);
            }
            algo.needRedraw = true;
        }, 1000);
        //unhighlight previous path
        if(new_edges.length > 0){
            for(var i in new_edges[new_edges.length-1]){
                var edge = new_edges[new_edges.length-1][i];
                edge.setLayout('lineColor','black');
            }
        }
        new_edges.push(edges_on_path);
        current++;
        statusID = ADD_PATH;
        // Erklärung im Statusfenster
        $("#ta_div_statusErklaerung").html("<h3>4. " + LNG.K('algorithm_new_paths') + "</h3>"
        + "<p>" + LNG.K('algorithm_add_path_1') + "</p>"
        + "<p>" + LNG.K('algorithm_add_path_2') + "</p>"
        + "<p>" + LNG.K('algorithm_add_path_cost') + cost + "</p>");
        if(current >= matching.length){
            statusID = SHOW_TOUR;
            // Erklärung im Statusfenster
            $("#ta_div_statusErklaerung").append(
            //+ "<p>" + LNG.K('algorithm_add_path_3') + "</p>" +
            "<p>" + LNG.K('algorithm_balanced_1') + "</p>");
        }
    };
/*    this.findUnbalancedNodes = function () {
        for (var n in graph.nodes){
            var node = graph.nodes[n];
            var d = Object.keys(node.getOutEdges()).length - Object.keys(node.getInEdges()).length;
            delta[node.getNodeID()] = d;
            if(d < 0) supplyNodes.push(node);
            else if(d > 0) {
                demandNodes.push(node);
                excess+=d;
            }
        }
    };*/

        //color edges
/*        for(var i = 0; i < subtours.length; i++) {
            var cur = subtours[i];
            for(var j = 0; j < cur['tour'].length; j++) {
                if(cur['tour'][j].type == "edge") {
                    var edge = graph.edges[cur['tour'][j].id];
                    edge.setLayout('lineColor', tourColors[cur['color']]);
                    //edge.weight = null;
                }
            }
        }*/