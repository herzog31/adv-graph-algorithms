{ 
  "name": "de",
  "fields" : {
    "algorithm_btn_prev": "Zurück",
    "algorithm_btn_next": "Nächster Schritt",
    "algorithm_btn_frwd": "Vorspulen",
    "algorithm_btn_paus": "Pause",
    "algorithm_msg_finish": "Was nun?",
    "algorithm_msg_test": "Forschungsaufgaben ausprobieren:",
    "algorithm_btn_more": "Beschreibung des Algorithmus lesen",
    "algorithm_btn_exe1": "Wie würde der Algorithmus entscheiden?",
    "algorithm_btn_exe2": "Finde selbst einen Rundgang",
    "algorithm_status1": "Kosten des Anfangsknotens: ",
    "algorithm_status2": "Kosten der Kante: ",
    "algorithm_status3": "Kosten des Zielknotens: ",
    "algorithm_status4": "Die Kosten des Zielknotens müssen aktualisiert werden.",
    "algorithm_status5": "Die Kosten des Zielknotens können nicht aktualisiert werden.",

    "algorithm_text_phase": "Phase",
    "algorithm_text_of": "von",
    "algorithm_text_here": "hier",
    "algorithm_text_floyd_warshall": "Floyd-Warshall-Algorithmus",
    "algorithm_link_floyd_warshall": "../floyd-warshall/index.html",
    "algorithm_text_hierholzer": "Hierholzer-Algorithmus",
    "algorithm_link_hierholzer": "../hierholzer/index.html",
    "algorithm_text_hungarian": "Ungarische Methode",
    "algorithm_link_hungarian": "../hungarian/index.html",
    "algorithm_init": "Initialisierung",
    "algorithm_feasibility": "Prüfen ob das Problem lösbar ist",
    "algorithm_feasible_0": "Als erstes wird geprüft, ob der Graph stark zusammenhängend ist und ob es negative Kreise im Graphen gibt. ",
    "algorithm_feasible_0_1": "Ein Graph ist stark zusammenhängend, wenn von jedem Knoten aus alle anderen Knoten erreichbar sind. Nur dann existiert ein Rundgang im Graphen.",
    "algorithm_feasible_1": "Der Graph ist stark zusammenhängend. Dann existiert ein Rundgang, der alle Kanten benutzt.",
    "algorithm_feasible_2": "Es existieren keine negativen Kreise. Die Kosten eines Rundgangs sind nach unten beschränkt.",
    "algorithm_feasible": "Das Problem ist auf diesem Graphen lösbar.",
    "algorithm_infeasible_1": "Der Graph ist nicht stark zusammenhängend. Es existiert kein Rundgang, der alle Kanten des Graphen enthält.",
    "algorithm_infeasible_2": "Es existiert ein negativer Kreis im Graphen. Die Kosten eines Rundgangs können unendlich klein werden, indem man unendlich oft den Kreis abläuft.",
    "algorithm_infeasible": "Das Problem ist auf diesem Graphen nicht lösbar.",

    "algorithm_find_balanced_nodes": "Finden von Knoten mit ungleichem Eingangs- und Ausgangsgrad",
    "algorithm_find_balanced_nodes_1": "Zuerst wird die Differenz zwischen Ausgangs- und Eingangsgrad der Knoten berechnet. Knoten mit der Differenz 0 sind balanciert. Alle anderen Knoten sind unbalanciert. Unbalancierte Knoten sind farbig markiert. Die Differenzen sind in die Knoten eingetragen.",
    "algorithm_balanced_1": "Bei allen Knoten im Graphen stimmt der Eingangsgrad mit dem Ausgangsgrad überein. Dann existiert eine Eulertour im Graphen. Ein Eulerkreis(oder Eulertour) ist ein Weg im Graphen, der alle Kanten genau einmal enthält und bei dem die Start- und Endknoten übereinstimmen. ",
    "algorithm_balanced_2": "In der Eulertour werden die Kanten nur einmal benutzt. Also ist es die optimale Lösung.",
    "algorithm_unbalanced_1": "Falls alle Knoten balanciert sind, so existiert ein Eulerkreis im Graphen. Ein Eulerkreis (oder Eulertour) ist ein Weg im Graphen, der alle Kanten genau einmal enthält und bei dem die Start- und Endknoten übereinstimmen. ",
    "algorithm_unbalanced_2": "Das Ziel der nächsten Schritte ist eine Menge von Pfaden zwischen unbalancierten Knoten zu finden, sodass nach dem Einfügen dieser Pfade in den Graphen alle Knoten balanciert sind. Die Länge der zusätzlichen Pfade sollte minimal sein.",
    "algorithm_unbalanced_3": "Die Eulertour des Graphen mit zusätzlichen Pfaden ist der gesuchte kürzeste Rundgang. ",

    "algorithm_paths": "Bestimmen von zusätzlichen Pfaden",
    "algorithm_paths_1": "Es werden nur unbalancierte Knoten betrachtet. Die Kantengewichte repräsentieren die Längen der kürzesten Pfade von den Knoten mit negativer Differenz zwischen dem Ausgangs- und dem Eingangsgrad zu den Knoten mit positiven Differenz.",
    "algorithm_paths_2": "Um die kürzesten Pfade zwischen den Knoten zu finden, wird der ",
    "algorithm_paths_2_1": " eingesetzt.",
    "algorithm_paths_3": "Durch Einfügen eines zusätzlichen Pfades von einem Knoten mit negativer Differenz zwischen dem Ausgangs- und dem Eingangsgrad zu einem Knoten mit positiven Differenz, ändert sich die Differenz an den Endknoten um genau 1. Bei allen anderen Knoten v auf diesem Weg ändert sich die Differenz zwischen dem Ausgangs- und dem Eingangsgrad nicht.",
    "algorithm_paths_4": "Es wird eine Menge von Pfaden gesucht, sodass alle Knoten balanciert sind und die Länge der Pfade minimal ist.",

    "algorithm_matching_1": "Die optimale Menge von Pfaden wird durch die markierten Kanten gezeigt.",
    "algorithm_matching_2": "Um die optimale Menge von Pfaden zu bestimmen, kann man den Algorithmus zum Finden von maximalen Matchings einsetzen, zum Beispiel die ",
    "algorithm_matching_3": "Die Differenz zwischen Ausgangs- und Eingangsgrad der unbalancierten Knoten wird 0. Alle Knoten auf dem Weg zwischen den markierten Knoten behalten die gleiche Differenz wie vorher.",

    "algorithm_new_paths": "Einfügen von zusätzlichen Pfaden",
    "algorithm_new_paths_1": "Die zuvor bestimmten Pfade werden jetzt in den Graphen eingefügt. Die neu eingefügten Kanten repräsentieren die Kanten des originalen Graphen, die mehrmals durchlaufen werden müssen.",
    "algorithm_new_paths_2": "Nach dem Einfügen ist bei allen Knoten die Differenz zwischen Ausgangs- und Eingangsgrad gleich 0. Dann existiert eine Eulertour in diesem Graphen.",
    "algorithm_new_paths_3": "Klicke auf Nächster Schritt, um mit dem Einfügen von zusätzlichen Pfaden zu beginnen.",

    "algorithm_add_path_1": "Es wird ein zusätzlicher kürzester Pfad zwischen den hervorgehobenen Knoten hinzugefügt. ",
    "algorithm_add_path_2": "Die Differenz zwischen Ausgangs- und Eingangsgrad der Endknoten verändert sich um genau 1. ",
    "algorithm_add_path_cost": "Kosten des Pfades: ",

    "algorithm_tour": "Bestimmen des Eulerkreises",
    "algorithm_tour_hierholzer_1": "Zum Auffinden des Eulerkreises wird der ",
    "algorithm_tour_hierholzer_2": " benutzt. ",
    "algorithm_tour_hierholzer_3": "Die Kosten des günstigsten Rundgangs sind genau die Kosten einer Eulertour im Graphen. Die Kosten einer Eulertour stellen die Summe der Kantengewichte aller Kanten im Graphen dar.",
    "algorithm_start_tour_1": "Bei allen Knoten im Graphen stimmt der Eingangsgrad mit dem Ausgangsgrad überein. Dann existiert ein Eulerkreis im Graphen.",
    "algorithm_start_tour_2": "Wir starten mit einem beliebigen Knoten und folgen den Kanten, bis alle Kanten einmal durchlaufen sind und wir wieder zum Startknoten zurückkehren.",
    "algorithm_start_tour_3": "Zum Auffinden des Eulerkreises wird der Algorithmus von Hierholzer benutzt.",
    "algorithm_end_tour_1": "Wir kehren wieder zum Startknoten zurück. Alle Kanten wurden einmal benutzt.",
    "algorithm_end_tour_2": "Der Eulerkreis wurde gefunden.",
    "algorithm_cost": "Die Kosten der Eulertour betragen: ",
    "algorithm_cost_optimal": "Die Kosten des optimalen Rundgangs betragen: ",
    "algorithm_end": "Der Algorithmus ist beendet.",
    "algorithm_end_success": "Der kürzeste Rundgang wurde gefunden.",
    "algorithm_end_failure": "Das Problem ist auf diesem Graphen nicht lösbar.",

    "algorithm_euler": "Bestimmen des Eulerkreises.",
    "algorithm_euler_subtours": "Subtouren",
    "algorithm_status5_desc1b": "Der Algorithmus konnte erfolgreich eine Eulertour bestimmen.",
    "algorithm_status51b_head": "Eulertour",
    "algorithm_status51b_desc1": "Die Eulertour wird hier als Folge von Knoten dargestellt.",
    "algorithm_status51b_desc2": "Animiere Eulertour",
    "algorithm_status51b_desc3": "Stop",
    "algorithm_status51b_desc4": "Klicke auf <strong>Animiere Eulertour</strong> um die komplette Eulertour abzulaufen und alle Knoten und Kanten auf dem Weg hervorzuheben.",
    "algorithm_status52_head": "Subtouren",
    "algorithm_status52_desc1": "Bewege deinen Mauszeiger über eine der Subtouren, um sie im Graph hervorzuheben.",
    "algorithm_link_euler": "Der Eulerkreises kann mit dem Hierholzer-Algorithmus gefunden werden. Wie der Hierholzer-Algorithmus arbeitet kann man hier betrachten: ",

    "aufgabe1_qst": "Frage",
    "aufgabe1_qst_solution": "Lösung",
    "aufgabe1_qst_answer": "Antworten",
    "aufgabe1_qst_close": "Schließen",
    "aufgabe1_qst_correct": "korrekt",
    "aufgabe1_qst_wrong": "falsch",
    "aufgabe1_qst_correctanswer": "Die korrekte Antwort ist: ",
    "aufgabe1_qst_continue": "Weiter",
    "aufgabe1_btn_next_question": "Zur nächsten Frage vorspulen",
    "aufgabe1_btn_retry": "Nochmal versuchen",
    "aufgabe1_btn_exe2": "Probiere die zweite Forschungaufgabe:",
    "aufgabe1_btn_answer": "Antworten",
    "aufgabe1_question1": "Ist der hervorgehobene Knoten balanciert?",
    "aufgabe1_question2": "Wie viele zusätzliche Kanten müssen in den Knoten reingehen bzw. rausgehen, damit er balanciert wird?",
    "aufgabe1_question3": "Was ist die Länge des kürzesten Weges der hervorgehobenen Matching-Kante?",
    "aufgabe1_correct_answer": "Die korrekte Antwort ist:",
    "aufgabe1_answer1_reason2": "Die Anzahl von Eingangs- und Ausgangskanten unterscheidet sich.",
    "aufgabe1_answer1_reason1": "Der Knoten besitzt die gleiche Anzahl von Eingangs- und Ausgangskanten.",
    "aufgabe1_answer2_reason1": "Die Differenz zwischen Ausgangs- und Eingangsgrad bestimmt die Anzahl von zusätzlichen Pfaden die im Knoten enden bzw. anfangen.",
    "aufgabe1_answer2_reason2": "Die Anzahl von Eingangs- und Ausgangskanten unterscheidet sich.",
    "aufgabe1_answer3_reason1": "Der länge des kürzesten Weges kann auf der Matching-Kante abgelesen werden.",
    "aufgabe1_text_yes": "Ja",
    "aufgabe1_text_no": "Nein",
    "aufgabe1_text_infinity": "Unendlich",
    "aufgabe1_text_question": "Frage",
    "aufgabe1_text_results": "Ergebnisse",
    "aufgabe1_text_right_answer": "Richtige Antwort:",
    "aufgabe1_result1": "Herzlichen Glückwunsch!",
    "aufgabe1_result2": "Du hast alle Fragen korrekt beantwortet.",
    "aufgabe1_result3": "Forschungsaufgabe beendet",
    "aufgabe1_result4": "Anzahl Fragen:",
    "aufgabe1_result5": "Richtig beantwortet:",
    "aufgabe1_result6": "Falsch beantwortet:",

    "aufgabe2_header": "Bestimme den Weg des Postboten",
    "aufgabe2_legend": "Mit einem Linksklick wählst du die nächste Kante auf dem Rundweg aus und mit einem Rechtsklich kann du deine Wahl rückgängigmachen.",
    "aufgabe2_path": "Die erste Kante kannst du frei bestimmen. Alle weiteren Kanten müssen von letztem Knoten kommen. ",
    "aufgabe2_not_used": "Diese Kante .",
    "aufgabe2_used": "Klicke auf die Kanten um einen Rundweg zu bestimmen.",
    "aufgabe2_cost": "Die Kosten der angegebenen Tour betragen: ",
    "aufgabe2_optimal_cost": "Die optimalen Kosten betragen: ",
    "aufgabe2_tour_completed": "Die Tour wurde abgeschlossen.",
    "aufgabe2_not_feasible": "Das Problem ist auf diesem Graphen nicht lösbar. Bitte wählen Sie einen anderen Graphen aus.",
    "aufgabe2_btn_animation": "Animiere deine Eulertour",
    "aufgabe2_animation": "Klicke auf <strong>Animiere deine Eulertour</strong> um deine Eulertour abzulaufen und alle Knoten und Kanten auf dem Weg hervorzuheben.",
    "aufgabe2_btn_execution": "Optimale Tour finden",
    "aufgabe2_execution": "Klicke auf <strong>Optimale Tour finden</strong> um den Briefträger-Algorithmus auf diesem Graphen auszuführen.",
    "aufgabe2_btn_more": "Weitere Informationen über den Algorithmus"
  }
}
