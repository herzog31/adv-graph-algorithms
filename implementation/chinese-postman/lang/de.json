{ 
  "name": "de",
  "fields" : {
    "algorithm_btn_prev": "Zurück",
    "algorithm_btn_next": "Nächster Schritt",
    "algorithm_btn_frwd": "Vorspulen",
    "algorithm_btn_paus": "Pause",
    "algorithm_msg_finish": "Was nun?",
    "algorithm_msg_test": "Forschungsaufgaben ausprobieren:",
    "algorithm_btn_more": "Beschreibung des Algorithmus lesen",
    "algorithm_btn_exe1": "Wie würde der Algorithmus entscheiden?",
    "algorithm_btn_exe2": "Welche Sortierung der Kanten ist optimal?",
    "algorithm_status1": "Kosten des Anfangsknotens: ",
    "algorithm_status2": "Kosten der Kante: ",
    "algorithm_status3": "Kosten des Zielknotens: ",
    "algorithm_status4": "Die Kosten des Zielknotens müssen aktualisiert werden.",
    "algorithm_status5": "Die Kosten des Zielknotens können nicht aktualisiert werden.",

    "algorithm_text_oneedge": "eine Kante",
    "algorithm_text_edges": "Kanten",
    "algorithm_text_phase": "Phase",
    "algorithm_text_of": "von",
    "algorithm_init": "Initialisierung",
    "algorithm_feasibility": "Prüfen ob das Problem lösbar ist.",
    "algorithm_feasible_0": "Als erstes wird geprüft, ob der Graph einen Eulerkreis besitzt und ob es negative Kreise im Graphen gibt.",
    "algorithm_feasible_1": "Der Graph ist stark zusammenhängend. Dann muss es einen Rundgang existieren, der alle Kanten benutzt.",
    "algorithm_feasible_2": "Es existieren keine negativen Kreise. Die Kosten eines Rundgangs sind nach unten beschränkt.",
    "algorithm_feasible": "Das Problem ist lösbar.",
    "algorithm_infeasible_1": "Der Graph ist nicht stark zusammenhängend. Es existiert keinen Rundgang, der alle Kanten des Graphen benutzt.",
    "algorithm_infeasible_2": "Es existiert ein negativer Kreis im Graphen. Die Kosten eines Rundgangs können unendlich werden, indem man unendlich den Kreis abläuft.",
    "algorithm_infeasible": "Das Problem ist nicht lösbar.",

    "algorithm_find_balanced_nodes": "Finden von Knoten mit ungleichem Eingangs- und Ausgangsgrad",
    "algorithm_find_balanced_nodes_1": "Zuerst wird die Graddifferenz der Knoten berechnet. Dies ist die Differenz zwischen dem Ausgangs- und dem Eingangsgrad. Knoten mit Graddifferenz 0 sind balanciert. Alle anderen Knoten sind nicht balanciert.",
    "algorithm_balanced_1": "Bei allen Knoten im Graphen stimmt der Eingangsgrad mit dem Ausgangsgrad überein. Dann existiert eine Eulertour im Graphen.",
    "algorithm_balanced_2": "In der Eulertour werden die Kanten nur einmal benutzt. Also ist es die optimale Lösung.",
    "algorithm_unbalanced_1": "Unbalancierte Knoten sind farbig markiert. Falls alle Knoten balanciert sind, so existiert ein Eulerkreis im Graphen.",
    "algorithm_unbalanced_2": "Das Ziel des Algorithmen ist ein Menge von Pfaden zwischen nicht balancierten Knoten zu finden, sodass nach dem Einfügen dieser Pfade alle Knoten balanciert sind.",
    "algorithm_unbalanced_3": "Die Länge der zusätzlichen Pfade sollte minimal sein.",

    "algorithm_paths": "Bestimmen von zusätzlichen Pfaden.",
    "algorithm_paths_1": "Es werden nur nicht balancierte Knoten betrachtet. Die Kanten repräsentieren die Längen der kürzesten Pfade von den Knoten mit negativer Graddifferenz zu den Knoten mit positiver Graddifferenz.",
    "algorithm_paths_2": "Um die kürzesten Pfade zwischen den Knoten zu finden, kann man den Algorithmus von Floyd-Warshall einsetzen. Dieser Algorithmus wird hier vorgestellt:",
    "algorithm_paths_3": "Durch Einfügen eines zusätzlichen Pfades von einem Knoten mit negativer Graddifferenz zu einem Knoten mit positiver Graddifferenz, ändert sich die Graddifferenz an den Endknoten um genau eins. Die Graddifferenz aller anderen Knoten auf diesem Weg ändert sich nicht.",
    "algorithm_paths_4": "Es wird eine Mengen von Pfaden gesucht, sodass alle Knoten balanciert sind und die Länge der Pfade minimal ist.",
    "algorithm_matching_1": "Die optimale Menge von Pfaden wird durch die markierten Kanten gezeigt.",
    "algorithm_matching_2": "Um die optimale Menge von Pfaden zu bestimmen, kann man den Algorithmus zum Finden von maximalen Matchings einsetzen. Die Arbeitsweise dieses Algorithmen wird hier vorgestellt:",
    "algorithm_matching_3": "Die Graddifferenz der nicht balancierten Knoten wird 0. Alle Knoten auf dem Weg zwischen den markierten Knoten haben die gleiche Graddifferenz wie vorher.",

    "algorithm_new_paths": "Einfügen von zusätzlichen Pfaden.",
    "algorithm_new_paths_1": "Die zuvor bestimmten Pfade werden jetzt in den Graphen eingefügt. Die neu eingefügten Kanten repräsentieren, die Kanten des originalen Graphen, die wir mehrmals durchlaufen müssen.",
    "algorithm_new_paths_2": "Nach dem Einfügen besitzen alle Knoten die Graddifferenz von 0. Dann existiert eine Eulertour in diesem Graphen.",

    "algorithm_add_path_1": "Von Knoten mit negativer Graddifferenz wird ein Weg zu Knoten mit positiver Graddifferenz hinzugefügt.",
    "algorithm_add_path_2": "Die Graddifferenz der Endknoten verändert sich um genau eins.",
    "algorithm_add_path_cost": "Kosten des Weges: ",

    "algorithm_tour": "Bestimmen des Eulerkreises",
    "algorithm_tour_hierholzer": "Zum Auffinden des Eulerkreises wird der Algorithmus von Hierholzer benutzt. Die Funktionsweise dieses Algorithmen wird hier dargestellt:",
    "algorithm_start_tour_1": "Bei allen Knoten im Graphen stimmt der Eingangsgrad mit dem Ausgangsgrad überein. Dann existiert ein Eulerkreis im Graphen.",
    "algorithm_start_tour_2": "Wir starten mit einem beliebigen Knoten und folgen den Kanten, bis alle Kanten einmal durchlaufen sind und wir wieder zum Startknoten zurückkehren.",
    "algorithm_start_tour_3": "Zum Auffinden des Eulerkreises wird der Algorithmus von Hierholzer benutzt.",
    "algorithm_end_tour_1": "Wir kehren wieder zum Startknoten zurück. Alle Kanten wurden einmal benutzt.",
    "algorithm_end_tour_2": "Der Eulerkreis wurde gefunden.",
    "algorithm_cost": "Die Kosten der Eulertour betragen: ",
    "algorithm_end": "Der Algorithmus ist beendet.",
    "algorithm_end_success": "Der kürzeste Rundgang wurde gefunden.",
    "algorithm_end_failure": "Das Problem ist auf diesem Graphen nicht lösbar.",

    "algorithm_euler": "Bestimmen des Eulerkreises.",
    "algorithm_euler_subtours": "Subtouren.",
    "algorithm_status5_desc1b": "Der Algorithmus konnte erfolgreich eine Eulertour bestimmen.",

    "algorithm_status51b_head": "Eulertour",
    "algorithm_status51b_desc1": "Die Eulertour wird hier als Folge von Knoten dargestellt.",
    "algorithm_status51b_desc2": "Animiere Eulertour",
    "algorithm_status51b_desc3": "Stop",
    "algorithm_status51b_desc4": "Klicke auf <strong>Animiere Eulertour</strong> um die komplette Eulertour abzulaufen und alle Knoten und Kanten auf dem Weg hervorzuheben.",

    "algorithm_status52_head": "Subtouren",
    "algorithm_status52_desc1": "Bewege deinen Mauszeiger über eine der Subtouren, um sie im Graph hervorzuheben.",

    "algorithm_link_euler": "Der Eulerkreises kann mit dem Hierholzer-Algorithmus gefunden werden. Wie der Hierholzer-Algorithmus arbeitet kann man hier betrachten: ",

    "aufgabe1_btn_next_question": "Zur nächsten Frage vorspulen",
    "aufgabe1_btn_retry": "Nochmal versuchen",
    "aufgabe1_btn_exe2": "Probiere die zweite Forschungaufgabe:",
    "aufgabe1_question1": "Welchen Abstandswert wird der Algorithmus für den roten Knoten eintragen?",
    "aufgabe1_answer1": "Unendlich",
    "aufgabe1_answer1_reason": "Da der Algorithmus noch keine Berechnungen durchgeführt hat, haben alle Knoten den Abstand unendlich zum Startknoten.",
    "aufgabe1_answer2_reason1": "Der Wert des Knotens wurde aktualisiert, weil über die rote Kante eine Abkürzung möglich war.",
    "aufgabe1_answer2_reason2": "Es ist",
    "aufgabe1_answer2_reason3": "Der Wert des Knotens wurde nicht verändert, weil keine Abkürzung über die rote Kante möglich war.",
    "aufgabe1_question3": "Weist die rote Kante auf einen erreichbaren negativen Kreis hin?",
    "aufgabe1_answer3_reason1": "Die Kante ist \"inkonsistent\", es ist immernoch einer Abkürzung über diese Kante möglich.",
    "aufgabe1_answer3_reason2": "Beweis:",
    "aufgabe1_answer3_reason3": "Die Kante ist \"konsistent\", es ist keine Abkürzung über diese Kante möglich.",
    "aufgabe1_msg_case3_4": "Der Kreis ist in hellrot im Graph markiert.",
    "aufgabe1_text_yes": "Ja",
    "aufgabe1_text_no": "Nein",
    "aufgabe1_text_infinity": "Unendlich",
    "aufgabe1_text_question": "Frage",
    "aufgabe1_text_results": "Ergebnisse",
    "aufgabe1_text_right_answer": "Richtige Antwort:",
    "aufgabe1_result1": "Herzlichen Glückwunsch!",
    "aufgabe1_result2": "Du hast alle Fragen korrekt beantwortet.",
    "aufgabe1_result3": "Forschungsaufgabe beendet",
    "aufgabe1_result4": "Anzahl Fragen:",
    "aufgabe1_result5": "Richtig beantwortet:",
    "aufgabe1_result6": "Falsch beantwortet:",
    "aufgabe2_btn_rev": "Letzte Auswahl rückgängig machen",
    "aufgabe2_btn_more": "Weitere Informationen über den Algorithmus",
    "aufgabe2_msg_1": "Der Algorithmus hat nun die Abstandswerte aller Knoten initialisiert.",
    "aufgabe2_msg_2": "Klicke auf die Kante, die der Algorithmus als Erstes überprüfen soll.",
    "aufgabe2_msg_3": "Update der Kanten",
    "aufgabe2_msg_4": "Der Algorithmus hat nun geprüft, ob über die gewählte Kante eine Abkürzung möglich ist, und die Abstandswerte aktualisiert.",
    "aufgabe2_msg_5": "Klicke auf die Kante, die als nächstes überprüft werden soll.",
    "aufgabe2_result_1": "Da keine Kanten existieren ist die gewählte Kantenreihenfolge optimal.",
    "aufgabe2_result_2": "Die gewählte Kantenreihenfolge ist optimal, der Bellman-Ford-Algorithmus würde nach nur einer Phase bereits ein korrektes Ergebnis haben.",
    "aufgabe2_result_3": "Ergebnis",
    "aufgabe2_result_4_a": "Der Graph enthält einen erreichbaren negativen Kreis. Da dies erst am Ende erkannt werden kann, hätte der Algorithmus alle",
    "aufgabe2_result_4_b": "Phasen",
    "aufgabe2_result_4_c": "benötigt. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_result_5_a": "Mit dieser Reihenfolge würde der Algorithmus nach",
    "aufgabe2_result_5_b": "ein korrektes Ergebnis haben. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_explan1": "Welche Reihenfolgen sind optimal?",
    "aufgabe2_explan2": "Leider ist es aufwendig, die optimale Reihenfolge zu finden. Es ist genauso schwierig (also langwierig), wie der Algorithmus selbst.",
    "aufgabe2_explan3": "Wofür braucht man eine gute Sortierung?",
    "aufgabe2_explan4": "In der Praxis ist es sinnvoll, den Algorithmus abzubrechen, sobald die letzte Phase keine Veränderung mehr brachte, denn dann ist das Ergebnis optimal.",
    "aufgabe2_explan5": "Es existieren heuristische Verfahren (Näherungsverfahen), die eine möglichst gute Sortierung zu ermitteln versuchen."
  }
}
