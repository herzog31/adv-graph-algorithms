{ 
  "name": "de",
  "fields" : {
    "algorithm_btn_prev": "Zurück",
    "algorithm_btn_next": "Nächster Schritt",
    "algorithm_btn_frwd": "Vorspulen",
    "algorithm_btn_paus": "Pause",
    "algorithm_msg_finish": "Was nun?",
    "algorithm_msg_test": "Forschungsaufgaben ausprobieren:",
    "algorithm_btn_more": "Beschreibung des Algorithmus lesen",
    "algorithm_btn_exe1": "Wie würde der Algorithmus entscheiden?",
    "algorithm_btn_exe2": "Welche Sortierung der Kanten ist optimal?",
    "algorithm_status1": "Kosten des Anfangsknotens: ",
    "algorithm_status2": "Kosten der Kante: ",
    "algorithm_status3": "Kosten des Zielknotens: ",
    "algorithm_status4": "Die Kosten des Zielknotens müssen aktualisiert werden.",
    "algorithm_status5": "Die Kosten des Zielknotens können nicht aktualisiert werden.",
    "textdb_text_oneedge": "eine Kante",
    "textdb_text_edges": "Kanten",
    "textdb_text_phase": "Phase",
    "textdb_text_of": "von",
    "textdb_init": "Initialisierung",
    "textdb_init_1": "Der Algorithmus hat nun die erste Schätzung der Kosten für jeden Knoten eingetragen.",
    "textdb_init_2": "Die Zahl im Knoten entspricht also der ersten Schätzung der Kosten des günstigsten Weges vom Startknoten zu diesem Knoten.",
    "textdb_init_3": "Da noch keine Berechnungen durchgeführt wurden, schätzen wir zunächst unendliche Kosten für alle Knoten außer dem Startknoten selbst.",

    "textdb_feasible": "Der Graph ist stark zusammenhängend",
    "textdb_feasible_1": "Es existiert einen Rundgang, der alle Kanten benutzt.",
    "textdb_feasible_2": "sdgfsdfgasdfasdf.",
    "textdb_infeasible": "Der Graph ist nicht stark zusammenhängend",
    "textdb_infeasible_1": "Es existiert keinen Rundgang.",
    "textdb_infeasible_2": "sdgfsdfgasdfasdf.",
    "textdb_balanced": "Finden von unbalancierten Knoten.",
    "textdb_balanced_1": "Bei allen Knoten im Graphen stimmt die Anzahl der Eingangsknoten mit der Anzahl der Ausgangsknoten überein.",
    "textdb_balanced_2": "Dann existiert eine Eulertour im Graphen. In der Eulertour werden die Kanten nur einmal benutzt. Also ist es die optimale Lösung.",
    "textdb_unbalanced": "Finden von unbalancierten Knoten.",
    "textdb_unbalanced_1": "Unbalancierte Knoten werden farbig markiert.",
    "textdb_unbalanced_2": "Es wird nun überprüft, ob die rote Kante einen besseren Weg zu ihrem Zielknoten ermöglicht als bisher bekannt.",
    "textdb_paths": "Kürzeste Wege berechnen",
    "textdb_paths_1": "Bis jetzt wurden alle günstigsten Wege korrekt berechnet, die maximal ",
    "textdb_paths_2": "benutzen.",
    "textdb_add_path": "Neuer Pfad",
    "textdb_add_path_1": "Es gibt einen neuen Pfad",
    "textdb_add_path_2": "Eingangs-, Ausgangskanten der Endpunkte vergrößert.",
    "textdb_add_path_3": "Alle Wege hinzugefügt.",
    "textdb_start_tour": "Eulertour starten.",
    "textdb_start_tour_1": "Eingangs-, Ausgangskanten der Endpunkte gleich.",
    "textdb_start_tour_2": "Start mit beliebiger Kante.",
    "textdb_start_tour_3": "blabla.",
    "textdb_next_edge": "Nächste Kante",
    "textdb_next_edge_1": "blabla.",
    "textdb_next_edge_1": "blablabla.",

    "aufgabe1_btn_next_question": "Zur nächsten Frage vorspulen",
    "aufgabe1_btn_retry": "Nochmal versuchen",
    "aufgabe1_btn_exe2": "Probiere die zweite Forschungaufgabe:",
    "aufgabe1_question1": "Welchen Abstandswert wird der Algorithmus für den roten Knoten eintragen?",
    "aufgabe1_answer1": "Unendlich",
    "aufgabe1_answer1_reason": "Da der Algorithmus noch keine Berechnungen durchgeführt hat, haben alle Knoten den Abstand unendlich zum Startknoten.",
    "aufgabe1_answer2_reason1": "Der Wert des Knotens wurde aktualisiert, weil über die rote Kante eine Abkürzung möglich war.",
    "aufgabe1_answer2_reason2": "Es ist",
    "aufgabe1_answer2_reason3": "Der Wert des Knotens wurde nicht verändert, weil keine Abkürzung über die rote Kante möglich war.",
    "aufgabe1_question3": "Weist die rote Kante auf einen erreichbaren negativen Kreis hin?",
    "aufgabe1_answer3_reason1": "Die Kante ist \"inkonsistent\", es ist immernoch einer Abkürzung über diese Kante möglich.",
    "aufgabe1_answer3_reason2": "Beweis:",
    "aufgabe1_answer3_reason3": "Die Kante ist \"konsistent\", es ist keine Abkürzung über diese Kante möglich.",
    "aufgabe1_msg_case3_4": "Der Kreis ist in hellrot im Graph markiert.",
    "aufgabe1_text_yes": "Ja",
    "aufgabe1_text_no": "Nein",
    "aufgabe1_text_infinity": "Unendlich",
    "aufgabe1_text_question": "Frage",
    "aufgabe1_text_results": "Ergebnisse",
    "aufgabe1_text_right_answer": "Richtige Antwort:",
    "aufgabe1_result1": "Herzlichen Glückwunsch!",
    "aufgabe1_result2": "Du hast alle Fragen korrekt beantwortet.",
    "aufgabe1_result3": "Forschungsaufgabe beendet",
    "aufgabe1_result4": "Anzahl Fragen:",
    "aufgabe1_result5": "Richtig beantwortet:",
    "aufgabe1_result6": "Falsch beantwortet:",
    "aufgabe2_btn_rev": "Letzte Auswahl rückgängig machen",
    "aufgabe2_btn_more": "Weitere Informationen über den Algorithmus",
    "aufgabe2_msg_1": "Der Algorithmus hat nun die Abstandswerte aller Knoten initialisiert.",
    "aufgabe2_msg_2": "Klicke auf die Kante, die der Algorithmus als Erstes überprüfen soll.",
    "aufgabe2_msg_3": "Update der Kanten",
    "aufgabe2_msg_4": "Der Algorithmus hat nun geprüft, ob über die gewählte Kante eine Abkürzung möglich ist, und die Abstandswerte aktualisiert.",
    "aufgabe2_msg_5": "Klicke auf die Kante, die als nächstes überprüft werden soll.",
    "aufgabe2_result_1": "Da keine Kanten existieren ist die gewählte Kantenreihenfolge optimal.",
    "aufgabe2_result_2": "Die gewählte Kantenreihenfolge ist optimal, der Bellman-Ford-Algorithmus würde nach nur einer Phase bereits ein korrektes Ergebnis haben.",
    "aufgabe2_result_3": "Ergebnis",
    "aufgabe2_result_4_a": "Der Graph enthält einen erreichbaren negativen Kreis. Da dies erst am Ende erkannt werden kann, hätte der Algorithmus alle",
    "aufgabe2_result_4_b": "Phasen",
    "aufgabe2_result_4_c": "benötigt. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_result_5_a": "Mit dieser Reihenfolge würde der Algorithmus nach",
    "aufgabe2_result_5_b": "ein korrektes Ergebnis haben. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_explan1": "Welche Reihenfolgen sind optimal?",
    "aufgabe2_explan2": "Leider ist es aufwendig, die optimale Reihenfolge zu finden. Es ist genauso schwierig (also langwierig), wie der Algorithmus selbst.",
    "aufgabe2_explan3": "Wofür braucht man eine gute Sortierung?",
    "aufgabe2_explan4": "In der Praxis ist es sinnvoll, den Algorithmus abzubrechen, sobald die letzte Phase keine Veränderung mehr brachte, denn dann ist das Ergebnis optimal.",
    "aufgabe2_explan5": "Es existieren heuristische Verfahren (Näherungsverfahen), die eine möglichst gute Sortierung zu ermitteln versuchen."
  }
}
