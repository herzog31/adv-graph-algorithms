{ 
  "name": "de",
  "fields" : {
    "algorithm_btn_prev": "Zurück",
    "algorithm_btn_next": "Nächster Schritt",
    "algorithm_btn_frwd": "Vorspulen",
    "algorithm_btn_paus": "Pause",
    "algorithm_msg_finish": "Was nun?",
    "algorithm_msg_test": "Forschungsaufgaben ausprobieren:",
    "algorithm_btn_more": "Beschreibung des Algorithmus lesen",
    "algorithm_btn_exe1": "Wie würde der Algorithmus entscheiden?",
    "algorithm_btn_exe2": "Welche Sortierung der Kanten ist optimal?",
    "algorithm_status1": "Kosten des Anfangsknotens: ",
    "algorithm_status2": "Kosten der Kante: ",
    "algorithm_status3": "Kosten des Zielknotens: ",
    "algorithm_status4": "Die Kosten des Zielknotens müssen aktualisiert werden.",
    "algorithm_status5": "Die Kosten des Zielknotens können nicht aktualisiert werden.",
    "textdb_text_oneedge": "eine Kante",
    "textdb_text_edges": "Kanten",
    "textdb_text_phase": "Phase",
    "textdb_text_of": "von",
    "textdb_init": "Initialisierung",
    "textdb_init_1": "Der Algorithmus hat nun die erste Schätzung der Kosten für jeden Knoten eingetragen.",
    "textdb_init_2": "Die Zahl im Knoten entspricht also der ersten Schätzung der Kosten des günstigsten Weges vom Startknoten zu diesem Knoten.",
    "textdb_init_3": "Da noch keine Berechnungen durchgeführt wurden, schätzen wir zunächst unendliche Kosten für alle Knoten außer dem Startknoten selbst.",
    "textdb_feasibility": "Prüfen ob das Problem lösbar ist.",
    "textdb_feasible_1": "Der Graph ist stark zusammenhängend. Dann muss es einen Rundgang existieren, der alle Kanten benutzt.",
    "textdb_feasible_2": "Es existieren keine negativen Kreise. Die Kosten eines Rundgangs sind nach unten beschränkt.",
    "textdb_feasible": "Das Problem ist lösbar.",
    "textdb_infeasible_1": "Der Graph ist nicht stark zusammenhängend. Es existiert keinen Rundgang, der alle Kanten des Graphen benutzt.",
    "textdb_infeasible_2": "Es existiert ein negativer Kreis in Graphen. Die Kosten eines Rundgangs können unendlich werden, indem man unendlich den Kreis abläuft.",
    "textdb_infeasible": "Das Problem ist nicht lösbar.",
    "textdb_find_balanced_nodes": "Finden von Knoten mit ungleichem Eingangs- und Ausgangsgrad",
    "textdb_balanced_1": "Bei allen Knoten im Graphen stimmt der Eingangsgrad mit dem Ausgangsgrad überein. Dann existiert eine Eulertour im Graphen.",
    "textdb_balanced_2": "In der Eulertour werden die Kanten nur einmal benutzt. Also ist es die optimale Lösung.",
    "textdb_unbalanced_1": "Unbalancierte Knoten werden farbig markiert. Knoten, die einen kleineren Ausgangsgrad als Eingangsgrad besitzten, sind grün markiert. Umgekehrt sind Knoten mir kleinerem Ausgangsgrad blau markiert.",
    "textdb_unbalanced_2": "Von den grün markerten Knoten werden neue Pfade zu den blau markierten Knoten in den Graphen hinzugefügt. Die Anzahl der Pfade von einem grünen Knoten beträgt genau die Differenz zwischen dem Eingangs- und dem Ausgangsgrad.",
    "textdb_unbalanced_3": "Gesucht ist eine Menge solcher Pfade, sodass ihre Länge minimal ist.",
    "textdb_paths": "Bestimmen von Pfaden zwischen den grünen und blauen Knoten.",
    "textdb_paths_1": "Gesucht ist eine Menge solcher Pfade, sodass ihre Länge minimal ist.",
    "textdb_paths_2": "Es werden nur Kanten eingeblendet, die auf den kürzesten Wegen zwischen zwei Knoten benutzt werden.",
    "textdb_add_path": "Einfügen eines neuen Pfades",
    "textdb_add_path_1": "Von einem grün markierten Knoten wird ein Pfad zu einem blau markeirten Knoten hinzugefügt.",
    "textdb_add_path_2": "Der Eingangsgrad des blauen Knotens und der Ausgangsgrad des grünen Knotens wird um eins erhöht.",
    "textdb_add_path_cost": "Kosten des Weges: ",
    "textdb_tour": "Auffinden des Eulerkreises",
    "textdb_start_tour_1": "Bei allen Knoten im Graphen stimmt der Eingangsgrad mit dem Ausgangsgrad überein. Dann existiert ein Eulerkreis im Graphen.",
    "textdb_start_tour_2": "Wir starten mit einem beliebigen Knoten und folgen den Kanten, bis alle Kanten einmal durchlaufen sind und wir wieder zum Startknoten zurückkehren.",
    "textdb_start_tour_3": "Zum Auffinden des Eulerkreises wird der Algorithmus von Hierholzer benutzt.",
    "textdb_next_edge": "Wir folgen der nächsten Kante.",
    "textdb_next_edge_1": "blabla.",
    "textdb_next_edge_2": "blablabla.",
    "textdb_end_tour_1": "Wir kehren wieder zum Startknoten zurück. Alle Kanten wurden einmal benutzt.",
    "textdb_end_tour_2": "Der Eulerkreis wurde gefunden.",
    "textdb_cost": "Die Kosten betragen: ",
    "textdb_end": "Der Algorithmus ist beendet.",
    "textdb_end_success": "Der kürzeste Rundgang wurde gefunden.",
    "textdb_end_failure": "Das Problem ist auf diesem Graphen nicht lösbar.",

    "algorithm_status5_head": "Ergebnis",
    "algorithm_status5_desc1a": "Der Algorithmus konnte erfolgreich einen Eulerweg bestimmen.",
    "algorithm_status5_desc1b": "Der Algorithmus konnte erfolgreich eine Eulertour bestimmen.",

    "algorithm_status51a_head": "Eulerweg",
    "algorithm_status51a_desc1": "Der Eulerweg wird hier als Folge von Knoten dargestellt.",
    "algorithm_status51a_desc2": "Animiere Eulerweg",
    "algorithm_status51a_desc3": "Stop",
    "algorithm_status51a_desc4": "Klicke auf <strong>Animiere Eulerweg</strong> um den kompletten Eulerweg abzulaufen und alle Knoten und Kanten auf dem Weg hervorzuheben.",

    "algorithm_status51b_head": "Eulertour",
    "algorithm_status51b_desc1": "Die Eulertour wird hier als Folge von Knoten dargestellt.",
    "algorithm_status51b_desc2": "Animiere Eulertour",
    "algorithm_status51b_desc3": "Stop",
    "algorithm_status51b_desc4": "Klicke auf <strong>Animiere Eulertour</strong> um die komplette Eulertour abzulaufen und alle Knoten und Kanten auf dem Weg hervorzuheben.",

    "algorithm_status52_head": "Subtouren",
    "algorithm_status52_desc1": "Bewege deinen Mauszeiger über eine der Subtouren, um sie im Graph hervorzuheben.",

    "aufgabe1_btn_next_question": "Zur nächsten Frage vorspulen",
    "aufgabe1_btn_retry": "Nochmal versuchen",
    "aufgabe1_btn_exe2": "Probiere die zweite Forschungaufgabe:",
    "aufgabe1_question1": "Welchen Abstandswert wird der Algorithmus für den roten Knoten eintragen?",
    "aufgabe1_answer1": "Unendlich",
    "aufgabe1_answer1_reason": "Da der Algorithmus noch keine Berechnungen durchgeführt hat, haben alle Knoten den Abstand unendlich zum Startknoten.",
    "aufgabe1_answer2_reason1": "Der Wert des Knotens wurde aktualisiert, weil über die rote Kante eine Abkürzung möglich war.",
    "aufgabe1_answer2_reason2": "Es ist",
    "aufgabe1_answer2_reason3": "Der Wert des Knotens wurde nicht verändert, weil keine Abkürzung über die rote Kante möglich war.",
    "aufgabe1_question3": "Weist die rote Kante auf einen erreichbaren negativen Kreis hin?",
    "aufgabe1_answer3_reason1": "Die Kante ist \"inkonsistent\", es ist immernoch einer Abkürzung über diese Kante möglich.",
    "aufgabe1_answer3_reason2": "Beweis:",
    "aufgabe1_answer3_reason3": "Die Kante ist \"konsistent\", es ist keine Abkürzung über diese Kante möglich.",
    "aufgabe1_msg_case3_4": "Der Kreis ist in hellrot im Graph markiert.",
    "aufgabe1_text_yes": "Ja",
    "aufgabe1_text_no": "Nein",
    "aufgabe1_text_infinity": "Unendlich",
    "aufgabe1_text_question": "Frage",
    "aufgabe1_text_results": "Ergebnisse",
    "aufgabe1_text_right_answer": "Richtige Antwort:",
    "aufgabe1_result1": "Herzlichen Glückwunsch!",
    "aufgabe1_result2": "Du hast alle Fragen korrekt beantwortet.",
    "aufgabe1_result3": "Forschungsaufgabe beendet",
    "aufgabe1_result4": "Anzahl Fragen:",
    "aufgabe1_result5": "Richtig beantwortet:",
    "aufgabe1_result6": "Falsch beantwortet:",
    "aufgabe2_btn_rev": "Letzte Auswahl rückgängig machen",
    "aufgabe2_btn_more": "Weitere Informationen über den Algorithmus",
    "aufgabe2_msg_1": "Der Algorithmus hat nun die Abstandswerte aller Knoten initialisiert.",
    "aufgabe2_msg_2": "Klicke auf die Kante, die der Algorithmus als Erstes überprüfen soll.",
    "aufgabe2_msg_3": "Update der Kanten",
    "aufgabe2_msg_4": "Der Algorithmus hat nun geprüft, ob über die gewählte Kante eine Abkürzung möglich ist, und die Abstandswerte aktualisiert.",
    "aufgabe2_msg_5": "Klicke auf die Kante, die als nächstes überprüft werden soll.",
    "aufgabe2_result_1": "Da keine Kanten existieren ist die gewählte Kantenreihenfolge optimal.",
    "aufgabe2_result_2": "Die gewählte Kantenreihenfolge ist optimal, der Bellman-Ford-Algorithmus würde nach nur einer Phase bereits ein korrektes Ergebnis haben.",
    "aufgabe2_result_3": "Ergebnis",
    "aufgabe2_result_4_a": "Der Graph enthält einen erreichbaren negativen Kreis. Da dies erst am Ende erkannt werden kann, hätte der Algorithmus alle",
    "aufgabe2_result_4_b": "Phasen",
    "aufgabe2_result_4_c": "benötigt. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_result_5_a": "Mit dieser Reihenfolge würde der Algorithmus nach",
    "aufgabe2_result_5_b": "ein korrektes Ergebnis haben. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_explan1": "Welche Reihenfolgen sind optimal?",
    "aufgabe2_explan2": "Leider ist es aufwendig, die optimale Reihenfolge zu finden. Es ist genauso schwierig (also langwierig), wie der Algorithmus selbst.",
    "aufgabe2_explan3": "Wofür braucht man eine gute Sortierung?",
    "aufgabe2_explan4": "In der Praxis ist es sinnvoll, den Algorithmus abzubrechen, sobald die letzte Phase keine Veränderung mehr brachte, denn dann ist das Ergebnis optimal.",
    "aufgabe2_explan5": "Es existieren heuristische Verfahren (Näherungsverfahen), die eine möglichst gute Sortierung zu ermitteln versuchen."
  }
}
