<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="Diese Seite demonstriert den Bellman-Ford-Algorithmus für kürzeste Wege in Graphen." />
    <meta http-equiv="X-UA-Compatible" content="IE=9">
    <meta name="author" content="Richard Stotz">
    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
    <link rel="stylesheet" type="text/css" href="../library/css/style.css" />
    <script src="js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <script src="js/lang.js" type="text/javascript"></script>
    <script src="js/utilities.js" type="text/javascript"></script>
    <script src="js/siteAnimation.js" type="text/javascript"></script>
    <script src="js/canvasDrawing.js" type="text/javascript"></script>
    <script src="js/graph.js" type="text/javascript"></script>
    <script src="js/algorithm.js" type="text/javascript"></script>
    <script src="js/aufgabe1.js" type="text/javascript"></script>
    <script src="js/aufgabe2.js" type="text/javascript"></script>
    <script src="js/floydWarshall.js" type="text/javascript"></script>
    <script src="js/maxMatching.js" type="text/javascript"></script>

    <title>Der Chinese-Postman-Algorithmus</title>
</head>
<body>
    <noscript>
        <div class="ui-widget">
            <div class="ui-state-error ui-corner-all" style="padding: .7em;">
                <div class="ui-icon ui-icon-alert errorIcon"></div>
                <strong>Bitte aktivieren Sie Javascript!</strong>
                <ul style="margin: 0;">
                    <li>
                        Diese Seite benötigt Javascript, um ordnungsgemäß angezeigt zu werden.
                    </li>
                    <li>
                        In Ihrem Browser ist Javascript aktuell deaktiviert. Eine Anleitung zur Aktivierung von Javascript finden Sie beispielsweise <a href="http://www.enable-javascript.com/">hier</a>.
                    </li>
                </ul>
            </div>
        </div>
    </noscript>
    <script>
        $(document).ready(initializeSiteLayout);
        LNG.setLanguage('de');
    </script>
    <header>
        <img src="img/titel.png" alt="Briefträgerproblem">
        <img style="position:absolute; right:0px" src="img/TUMLogo.png" alt="Technische Universität München">
    </header>
    <div id="tabs">
        <ul>
            <li><a href="#tab_te"><span>Einführung</span></a></li>
            <li><a href="#tab_tg"><span>Graph erstellen</span></a></li>
            <li><a href="#tab_ta"><span>Algorithmus ausführen</span></a></li>
            <li><a href="#tab_ti"><span>Beschreibung des Algorithmus</span></a></li>
            <li><a href="#tab_tf1"><span>Forschungsaufgabe 1</span></a></li>
            <li><a href="#tab_tf2"><span>Forschungsaufgabe 2</span></a></li>
            <li><a href="#tab_tw"><span>Weiteres</span></a></li>
        </ul>
        <div id="tab_te">
            <div id="te_div_Einfuehrungstext">
                <div id="te_div_beispiel1Container"><img id="te_img_beispiel1" src="img/intro.png" alt="Beispielproblem." height="209"><p>Welcher ist der günstigste Rundgang?</p></div>
                <h1>Der Weg des Postboten</h1>
                <p>Das Briefträgerproblem ist ein bekanntes Problem aus der Graphentheorie. Ein Postbote soll die Briefe in der Stadt auf dem kürzesten Weg zustellen.
                    Dabei muss er jede Straße mindestens einmal passieren und wieder zum Ursprung zurückkehren. Das Problem wird mittels eines Graphen modelliert.
                    Knoten stellen Kreuzungen dar und Kanten sind die Straßen. Die Länge der Straße entspricht dem Gewicht der zugehörigen Kante.
                </p>
                <h2>Hier wird der Chinese-Postman-Algorithmus für gerichtete Graphen vorgestellt, der den günstigsten Kantenzug findet, sodass jede Kante mindestens einmal benutzt wird.</h2>
                <div id ="te_div_Entscheidung">
                    <h2>Was möchtest du zuerst tun?</h2>
                    <button id="te_button_gotoDrawGraph">Den Algorithmus testen!</button> <button id="te_button_gotoIdee">Genauere Beschreibung des Algorithmus lesen</button>
                </div>
                <p></p>
            </div>
        </div>
        <div id="tab_tg">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tg_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tg_div_statusWindow" class="statusWindow">
                    <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                    <div id="tg_div_statusErklaerung">
                        <p>Um einen Knoten zu erstellen, mache einen Doppelklick in das Zeichenfeld.</p>
                        <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
                        <p>Das Kantengewicht kann mit einem Doppelklick auf die Kante verändert werden.</p>
                        <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
                    </div>
                    <h3>Keine Lust, selbst einen Graph zu erstellen?<br></h3>
                    <h3>Nimm ein fertiges Beispiel!<br></h3>
                    <select id="tg_select_GraphSelector" name="Wähle einen Graphen">
                        <option selected id="tg_selectoption_empty">Selbsterstellter Graph</option>
                        <option>Standardbeispiel</option>
                        <option>Zufallsgraph</option>
                        <option>Nicht Zusammenhängend</option>
                        <option>Kreis</option>
                        <option>Kreis2</option>
                        <option>5Knoten</option>
                        <option>Großstädte Europas</option>
                    </select>
                    <p><button id="tg_button_gotoAlgorithmTab">Fertig &ndash; weiter zum Algorithmus!</button></p>
                </div>
            </div>
            <div title="Graph erstellen" class="tabIntroDialog">
                <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                <p>Um einen Knoten zu erstellen, mache einen Doppelklick in das Zeichenfeld.</p>
                <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
                <p>Das Kantengewicht kann mit einem Doppelklick auf die Kante verändert werden.</p>
                <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
            </div>
        </div>
        <div id="tab_ta">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="ta_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende" id="ta_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="ta_div_statusWindow" class="statusWindow">
                    <h2 class="">Status des Algorithmus</h2>
                    <div id="ta_div_abspielbuttons">
                    </div>
                    <div id="ta_div_statusTabs">
                         <ul>
                            <li><a href="#ta_div_statusErklaerung">Erklärung</a></li>
                            <li><a href="#ta_div_statusPseudocode">Pseudocode</a></li>
                        </ul>
                        <div id="ta_div_statusErklaerung">
                            <h3>Initialisierung</h3>
                            <!--<p>Im nächsten Schritt wird festgestellt, ob das Briefträgerproblem auf dem Graphen lösbar ist. Dazu muss der Graph stark zusammenhängend sein. D.h. von jedem Knoten muss jeder andere Knoten erreichbar sein.</p>-->
                            <p>Zuerst werden alle Knoten gelöscht, die keine Eingangs- und Ausgangskanten besitzen. Diese isolierten Knoten haben keine Auswirkung auf den weiteren Verlauf des Algorithmus.</p>
                            <p>Kliche auf den "Nächster Schritt"-Button um den Algorithmus zu starten.</p>
                        </div>
                        <div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                            <p class="pseudocode" id="ta_p_begin">BEGIN</p>
                            <p class="pseudocode" id="ta_p_l">  1. Prüfen ob der das Problem lösbar ist</p>
                            <p class="pseudocode" id="ta_p_2">  2. Finden von nicht balancierten Knoten</p>
                            <p class="pseudocode" id="ta_p_3">  3. Bestimmen von zusätzlichen Pfaden</p>
                            <p class="pseudocode" id="ta_p_4">  4. Einfügen von zusätzlichen Pfaden</p>
                            <p class="pseudocode" id="ta_p_5">  5. Bestimmen von dem Eulerkreis</p>
                            <p class="pseudocode" id="ta_p_end">END</p>
<!--                            <h3>Status der Variablen:</h3>
                            <table class="algoInformationen">
                                <tr>
                                    <th class="algoInfoTH"><span>i</span></th>
                                    <th class="algoInfoTH"><span>d(u)</span></th>
                                    <th class="algoInfoTH"><span>d(v)</span></th>
                                    <th class="algoInfoTH"><span>l(u,v)</span></th>
                                </tr>
                                <tr>
                                    <td id="ta_td_vari" class="algoInfoTD"></td>
                                    <td id="ta_td_vardu" class="algoInfoTD"></td>
                                    <td id="ta_td_vardv" class="algoInfoTD"></td>
                                    <td id="ta_td_varluv" class="algoInfoTD"></td>
                                </tr>
                            </table>-->
                        </div>
                    </div>
                </div>
            </div>
            <div title="Algorithmus ausführen" class="tabIntroDialog">
                <h2>Den Briefträger-Algorithmus ausführen</h2>
                <p>In diesem Schritt sehen wir, wie der Algorithmus arbeitet.</p>
                <p>Rechts vom Graph kannst du die Ausführung kontrollieren.</p>
            </div>
            <div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird der Algorithmus abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>
        <div id="tab_ti" style="display: none;">
            <div id="ti_div_Einfuehrungstext">
                <div class="BeispielbildContainer">
<!--                    <img id="ti_img_beispiel01" src="img/not_strongly_connected.png" alt="Nicht stark-zusammenhängend" /><p>Nicht stark-zusammenhängend</p><br />
                    <img id="ti_img_beispiel02" src="img/negative_cycle.png" alt="Negativ" /><p>Negativer Kreis</p><br />-->
                    <img id="ti_img_beispiel1" src="img/grad.png" alt="Königsberger Brücken" /><p>Ausgangsgraph mit Graddifferenzen</p><br />
                    <img id="ti_img_beispiel3" src="img/matching.png" alt="Matching" /><p>Das Matching und durch Pfadeinfügungen entstandene Graph</p><br />
                    <img id="ti_img_beispiel4" src="img/tour.png" alt="Eulertour" /><p>Eulertour</p><br />
                </div>
                <h1>Briefträgerproblem</h1>
                <p>
                    Gegeben ist ein gerichteter und gewichteter Graph G. Das Briefträgerproblem besteht darin, einen geschlossenen Kantenzug im Graphen zu finden, sodass alle Kanten mindesten einmal
                    benutzt werden und die Summe der Kantengewichte des Kantenzugs (Kosten des Rundgangs) minimal ist. Ein Beispiel für dieses Problems ist ein Postbote, der alle Straßen
                    einer Stadt ablaufen muss und wieder zum Startpunkt zurückkehrt. Dabei will er eine möglichst kurze Distanz zurücklegen.
                </p>
                <h1>Idee des Algorithmen</h1>
                <p>
                    Da isolierte Knoten keinen Einfluss auf die Lösung des Problems haben, können wir annehmen, dass solche Knoten nicht existieren.
                    Das Problem ist genau dann lösbar, wenn der Graph stark zusammenhängend ist (jeder Knoten von jedem Knoten aus erreichbar) und keine negativen Kreise existieren.
                    Das Problem lässt sich auf das Bestimmen einer Eulertour im Graphen zurückführen. Falls es eine Eulertour im Graphen gibt,
                    so ist diese Tour das optimale Ergebnis, da jede Kante genau einmal besucht wird. Im anderen Fall müssen einige Kanten mehrmals besucht werden. Diese Situation lässt sich modellieren, indem
                    wir zusätzliche Kanten in den Graphen einfügen, die mehrmals benutzten Kanten repräsentieren (mit dem gleichen Gewicht wie die originale Kante). Dann besitzt der Rundgang die gleichen Kosten, wie
                    die Eulertour im neuen Graphen. Das Problem besteht jetzt darin, die mehrfach benutzten Kanten des minimalen Rundgangs zu bestimmen.
                </p>
                <p> Ein Theorem der Graphentheorie besagt, dass es genau dann eine Eulertour im Graphen gibt, wenn bei allen Knoten im Graphen der Eingangsgrad mit dem Ausgangsgrad übereinstimmt.
                    Also reicht es aus, wenn wir zusätzliche Pfade in den Graphen einfügen, sodass nach dem Einfügen bei allen Knoten im Graphen der Eingangsgrad mit dem Ausgangsgrad übereinstimmt.
                    Die Summe der Kantengewichte der Pfade sollte minimal sein.
                    Welche Pfade genau eingefügt werden, wird im Matching-Schritt des Algorithmen festgestellt.
                </p>
                <p>
                    Nachdem sichergestellt wurde, dass der Graph eine Eulertour besitzt, muss diese nur gefunden werden. Dies erfolgt mit einem geeigneten Algorithmus, wie z.B. dem Hierholzer-Algorithmus.
                    Die Kosten des optimalen Rundgangs werden durch die Summe aller Kantengewichte der Eulertour bestimmt.
                </p>
                <h1>Kürzeste Wege</h1>
                <p>
                    Für den Matching-Schritt des Algorithmen benötigt man die Abstände und die kürzesten Wege zwischen je zwei Knoten des Graphen.
                    Um die kürzesten Wege bestimmen, wird der Algorithmus von Floyd-Warshall benutzt.
                    <!--Dieser Algorithmus berechnet im Gegensatz zu Bellman-Ford-Algorithmus die kürzesten Wege zwischen allen Knoten. -->
                    Weitere Erklärungen zu diesem Algorithmen können hier gefunden werden.
                </p>
                <h1>Matching</h1>
                <p>
                    Durch Einfügen zusätzlicher Pfade wollen wir erreichen, dass bei allen Knoten im Graphen der Eingangsgrad mit dem Ausgangsgrad übereinstimmt. Dann existiert eine Eulertour im Graphen.
                    Wir bezeichnen mit der Graddifferenz die Differenz zwischen dem Ausgangs- und dem Eingangsgrad eines Knotens. Um zu bestimmen welche Pfade wir einfügen, muss eine Zuordnung von Knoten
                    mit negativer Graddifferenz zu den Knoten mit positiver Graddifferenz erfolgen. Dabei bestimmt die Graddifferenz die Anzahl der neuen Pfade, die in diesem Knoten anfangen bzw. enden müssen.
                    Ein Pfad vergrößert die Graddifferenz des Startknotens um eins und verringert die Graddifferenz des Zielknotens um eins.
                </p>
                <p>
                    Das Gewicht der zusätzlichen Pfade sollte minimal sein. Um dieses Ziel zu erreichen könnte man einen neuen bipartiten Graphen erstellen.
                    Knoten mit Graddifferenz ungleich 0 werden in zwei Partitionen unterteilt (negative und positive Graddifferenzen).
                    Die Graddifferenz bestimmt wie viele Exemplare des Knotens im bipartiten Graph vorkommen. Z.B. existieren von einem Knoten mit Graddifferenz 3 genau 3 Kopien im Graphen.
                    Das Gewicht einer Kante stellt die Länge des kürzesten Pfades von dem Knoten mit positiver Graddifferenz zu dem Knoten mit negativer Graddifferenz dar.
                    Die Summe der positiven Graddifferenzen ist gleich der negierten Summe der negativen Graddifferenzen.
                    Damit erhalten wir einen vollständigen bipartiten Graph. Wir wenden einen Algorithmus zur Lösung von gewichteten Matchings auf diesen Graphen.
                    Ein Algorithmus zur Lösung von gewichteten Matchings wird hier vorgestellt. Damit erhalten wir die optimale Zuordnung und können die neuen Pfade einfügen.
                    Die Kanten der Pfade repräsentieren die Kanten des optimalen Rundgangs, die mehrmals benutzt werden.
                </p>
                <h1>Eulertour</h1>
                <p>
                    Nach dem Einfügen von zusätzlichen Pfaden ist sichergestellt, dass es eine Eulertour im Graphen existiert. Um diese zu finden, kann der Algorithmus von Hierholzer verwendet werden.
<!--                    Dieser startet mit einem beliebigen Knoten und folgt den Kanten bis man wieder an den Startpunkt gelangt. Falls noch unbenutzte Kanten existieren, wiederholt man die Prozedur
                    mit einem Knoten auf der bereits gefundenen Tour und fügt die neue Tour in die alte ein. Dies wird wiederholt, bis alle Kanten benutzt wurden. -->
                    Eine detailierte Beschreibung des Algorithmen kann hier gefunden werden.
                    Die Kosten des optimalen Rundgangs werden durch die Summe aller Kantengewichte der Eulertour bestimmt.
                </p>
                <h1>Was nun?</h1>
                <br style="clear: both;" />
                <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                    <h3>Einen Graph erstellen und den Algorithmus durchspielen</h3>
                    <button id="ti_button_gotoDrawGraph">Graph erstellen und daran den Algorithmus testen</button>
                    <button id="ti_button_gotoAlgorithm">Algorithmus am fertigen Beispiel ausprobieren</button>
                </div>
                <div class="Entscheidungsweg" id="ti_div_EntscheidungRight">
                    <h3>Sein Wissen an den Forschungsaufgaben testen</h3>
                    <button id="ti_button_gotoFA1">Forschungsaufgabe: Wie würde der Algorithmus entscheiden?</button><br>
                    <button id="ti_button_gotoFA2">Forschungsaufgabe: Finde selber einen Rundgang</button>
                </div>
                <br style="clear: both;" />
            </div>
        </div>
        <div id="tab_tf1">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tf1_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tf1_div_statusWindow" class="statusWindow">
                    <h2 class="">Prüfe dein Wissen: Wie würde der Algorithmus entscheiden?</h2>
<!--                    <select id="tf1_select_aufgabeGraph" name="Wähle einen Graphen">
                        <option selected>Selbsterstellter Graph</option>
                        <option>Standardbeispiel</option>
                        <option>Negativer Kreis</option>
                        <option>Positiver Kreis</option>
                    </select>-->
                    <div id="tf1_div_abspielbuttons">
                    </div>
                    <div id="tf1_div_statusTabs">
                         <ul>
                            <li><a href="#tf1_div_statusErklaerung">Erklärung</a></li>
                            <li><a href="#tf1_div_statusPseudocode">Pseudocode</a></li>
                        </ul>
                        <div id="tf1_div_statusErklaerung">
                            <h2>In diesem Teil kann man sein Wissen testen: Wie würde der Algorithmus entscheiden?</h2>
                            <p>
                                Der Algorithmus wird normal ausgeführt, stoppt aber an einigen Stellen.
                                Du musst dann vorhersagen, wie der Algorithmus entscheiden würde.
                            </p>
                            <p>Tipp: Vorher nochmals die Beschreibung des Algorithmus durchlesen.</p>
                        </div>
                        <div class="PseudocodeWrapper" id="tf1_div_statusPseudocode">
                            <p class="pseudocode" id="tf1_p_begin">BEGIN</p>
                            <p class="pseudocode" id="tf1_p_l">  1. Prüfen ob der das Problem lösbar ist</p>
                            <p class="pseudocode" id="tf1_p_2">  2. Finden von nicht balancierten Knoten</p>
                            <p class="pseudocode" id="tf1_p_3">  3. Bestimmen von zusätzlichen Pfaden</p>
                            <p class="pseudocode" id="tf1_p_4">  4. Einfügen von zusätzlichen Pfaden</p>
                            <p class="pseudocode" id="tf1_p_5">  5. Bestimmen von dem Eulerkreis</p>
                            <p class="pseudocode" id="tf1_p_end">END</p>
                        </div>
                    </div>
                </div>
            </div>
            <div title="Forschungsaufgabe 1" class="tabIntroDialog">
                <h2>In diesem Teil kann man sein Wissen testen: Wie würde der Algorithmus entscheiden?</h2>
                <p>
                    Der Algorithmus wird normal ausgeführt, stoppt aber an einigen Stellen. 
                    Du musst dann vorhersagen, wie der Algorithmus entscheiden würde.
                </p>
                <p>Tipp: Vorher nochmals die Beschreibung des Algorithmus durchlesen.</p>
            </div>
            <div id="tf1_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>
        <div id="tab_tf2">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tf2_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tf2_div_statusWindow" class="statusWindow">
                    <h2>Finde selber einen Rundweg</h2>
                    <div id="tf2_div_Abspielbuttons"></div>
<!--                    <select id="tf2_select_aufgabeGraph" name="Wähle einen Graphen">
                        <option selected>Selbsterstellter Graph</option>
                        <option>Standardbeispiel</option>
                        <option>Negativer Kreis</option>
                        <option>Positiver Kreis</option>
                    </select>-->
                    <div id="tf2_div_statusErklaerung">
                        <h3>Klicke auf eine beliebige Kante, um mit der Aufgabe zu beginnen.</h3>
                        <p>Klicke danach in der Reihenfolge auf die Kanten, in der Sie der Postbote ablaufen soll.</p>
                        <p>Der Rundweg endet, wenn alle Kanten abgelaufen sind und der Postbote zum Anfangsknotenzurückkehrt.</p>
                    </div>
                    <div id="tf2_div_Frage">
                    </div>
                    <div id="tf2_div_Antworten">
                    </div>
                </div>
            </div>
            <div title="Forschungsaufgabe 2" class="tabIntroDialog">
                <h2>Klicke auf eine beliebige Kante, um mit der Aufgabe zu beginnen.</h2>
                <p>Klicke danach in der Reihenfolge auf die Kanten, in der Sie der Postbote ablaufen soll.</p>
                <p>Der Rundweg endet, wenn alle Kanten abgelaufen sind und der Postbote zum Anfangsknotenzurückkehrt.</p>
            </div>
            <div id="tf2_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>
        <div id="tab_tw">
            <div id="tw_Accordion">
                <h3>Wie sieht der (Pseudo-)Code des Algorithmus aus?</h3>
                <div><pre><code>
                    Eingabe: Gewichteter, ungerichteter Graph G=(V,E)
                    Ausgabe: Die Länge eines kürzesten Rundgangs, der alle Kanten enthält,
                             falls das Problem lösbar ist. Sonst unmöglich.
                    </code></pre>
                    <hr><pre><code>
                            BEGIN
                            1. Prüfen ob das Problem lösbar ist
                            2. Finden von nicht balancierte Knoten
                            3. Bestimmen von zusätzlichen Pfaden
                            4. Einfügen von zusätzlichen Pfaden
                            5. Bestimmen von dem Eulerkreis
                            END
                    </code></pre>
                </div>
                <h3>Wie schnell ist der Algorithmus?</h3>
                <div>
                    <p>
                        Die Laufzeit des Algorithmen hängt von der Laufzeit der benutzten Unteralgorithmen. Diese sind:
                    <li>
                        <ul>Kürzeste-Wege-Algorithmus </ul>
                        <ul>Algorithmus zur Bestimmung von optimalen zusätzlichen Pfaden (z.B Algorithmus zur Bestimmung von gewichteten Matchings)</ul>
                        <ul>Algorithmus zur Bestimmung von Eulertouren</ul>
                    </li>
                    Für alle diese Probleme existieren polynomielle Algorithmen. Demzufolge ist das Briefträgerproblem ebenfalls in polynomieller Zeit lösbar.
                    Die Implementierung auf dieser Seite benutzt den Floyd-Warshall-Algorithmus zur Bestimmung von kürzesten Wegen, ungarische Methode für die Lösung des Matching-Problems
                    und den Hierholzer-Algorithmus zum Finden der Eulertour.
                    </p>
                </div>
                <h3>Wie beweist man, dass der Algorithmus stets ein korrektes Ergebnis berechnet?</h3>
                <div>
                    <p>
                        
                    </p>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <p class="Disclaimer">
            IDP Projekt von Ruslan Zabrodin am Lehrstuhl M9 der Technischen Universität München. 2015 | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Disclaimer und Rechtshinweise</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">Impressum</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Anregungen</a>
        </p>
    </footer>
</body>