<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="Diese Seite demonstriert den Bellman-Ford-Algorithmus für kürzeste Wege in Graphen." />
    <meta http-equiv="X-UA-Compatible" content="IE=9">
    <meta name="author" content="Richard Stotz">
    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
    <link rel="stylesheet" type="text/css" href="../library/css/style.css" />
    <script src="js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <script src="js/lang.js" type="text/javascript"></script>
    <script src="js/utilities.js" type="text/javascript"></script>
    <script src="js/siteAnimation.js" type="text/javascript"></script>
    <script src="js/canvasDrawing.js" type="text/javascript"></script>
    <script src="js/graph.js" type="text/javascript"></script>
    <script src="js/algorithm.js" type="text/javascript"></script>
    <script src="js/aufgabe1.js" type="text/javascript"></script>
    <script src="js/aufgabe2.js" type="text/javascript"></script>
    <script src="../library/js/floydWarshall.js" type="text/javascript"></script>
    <script src="../library/js/maxMatching.js" type="text/javascript"></script>

    <title>Der Chinese-Postman-Algorithmus</title>
</head>
<body>
    <noscript>
        <div class="ui-widget">
            <div class="ui-state-error ui-corner-all" style="padding: .7em;">
                <div class="ui-icon ui-icon-alert errorIcon"></div>
                <strong>Bitte aktivieren Sie Javascript!</strong>
                <ul style="margin: 0;">
                    <li>
                        Diese Seite benötigt Javascript, um ordnungsgemäß angezeigt zu werden.
                    </li>
                    <li>
                        In Ihrem Browser ist Javascript aktuell deaktiviert. Eine Anleitung zur Aktivierung von Javascript finden Sie beispielsweise <a href="http://www.enable-javascript.com/">hier</a>.
                    </li>
                </ul>
            </div>
        </div>
    </noscript>
    <script>
        $(document).ready(initializeSiteLayout);
        LNG.setLanguage('de');
    </script>
    <header>
        <img src="img/titel.png" alt="Briefträgerproblem">
        <img style="position:absolute; right:0px" src="img/TUMLogo.png" alt="Technische Universität München">
    </header>
    <div id="tabs">
        <ul>
            <li><a href="#tab_te"><span>Einführung</span></a></li>
            <li><a href="#tab_tg"><span>Graph erstellen</span></a></li>
            <li><a href="#tab_ta"><span>Algorithmus ausführen</span></a></li>
            <li><a href="#tab_ti"><span>Beschreibung des Algorithmus</span></a></li>
            <li><a href="#tab_tf1"><span>Forschungsaufgabe 1</span></a></li>
            <li><a href="#tab_tf2"><span>Forschungsaufgabe 2</span></a></li>
            <li><a href="#tab_tw"><span>Weiteres</span></a></li>
        </ul>
        <div id="tab_te">
            <div id="te_div_Einfuehrungstext">
                <div id="te_div_beispiel1Container"><img id="te_img_beispiel1" src="img/beispiel1.png" alt="Einfacher Graph mit 4 Knoten."><p>Wie komme ich am günstigsten von links nach rechts?</p></div>
                <h1>Der Weg des Postboten</h1>
      <!--          <p>In vielen Anwendungen kann es nützlich sein, den kürzesten Weg von a nach b zu berechnen.
                Dabei muss die Länge eines Weges nicht unbedingt die Länge in Metern sein: Genauso gut kann man die Kosten eines Weges betrachten &ndash; man sucht also den <strong>günstigsten Weg</strong>.</p>
-->                <h2>Hier wird der Chinese-Postman-Algorithmus für gerichtete Graphen vorgestellt, der den günstigsten Kantenzug findet, sodass jede Kante mindestens einmal benutzt wird.</h2>
                <div id ="te_div_Entscheidung">
                    <h2>Was möchtest du zuerst tun?</h2>
                    <button id="te_button_gotoDrawGraph">Den Algorithmus testen!</button> <button id="te_button_gotoIdee">Genauere Beschreibung des Algorithmus lesen</button>
                </div>
                <p></p>
            </div>
        </div>
        <div id="tab_tg">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tg_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tg_div_statusWindow" class="statusWindow">
                    <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                    <div id="tg_div_statusErklaerung">
                        <p>Um einen Knoten zu erstellen, mache einen Doppelklick in das Zeichenfeld.</p>
                        <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
                        <p>Das Kantengewicht kann mit einem Doppelklick auf die Kante verändert werden.</p>
                        <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
                    </div>
                    <h3>Keine Lust, selbst einen Graph zu erstellen?<br></h3>
                    <h3>Nimm ein fertiges Beispiel!<br></h3>
                    <select id="tg_select_GraphSelector" name="Wähle einen Graphen">
                        <option selected id="tg_selectoption_empty">Selbsterstellter Graph</option>
                        <option>Standardbeispiel</option>
                        <option>Zufallsgraph</option>
                        <option>Nicht Zusammenhängend</option>
                        <option>Kreis</option>
                        <option>Kreis2</option>
                        <option>5Knoten</option>
                        <option>Großstädte Europas</option>
                    </select>
                    <p><button id="tg_button_gotoAlgorithmTab">Fertig &ndash; weiter zum Algorithmus!</button></p>
                </div>
            </div>
            <div title="Graph erstellen" class="tabIntroDialog">
                <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                <p>Um einen Knoten zu erstellen, mache einen Doppelklick in das Zeichenfeld.</p>
                <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
                <p>Das Kantengewicht kann mit einem Doppelklick auf die Kante verändert werden.</p>
                <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
            </div>
        </div>
        <div id="tab_ta">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="ta_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende" id="ta_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante mit Gewicht 50</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="ta_div_statusWindow" class="statusWindow">
                    <h2 class="">Status des Algorithmus</h2>
                    <div id="ta_div_abspielbuttons">
                    </div>
                    <div id="ta_div_statusTabs">
                         <ul>
                            <li><a href="#ta_div_statusErklaerung">Erklärung</a></li>
                            <li><a href="#ta_div_statusPseudocode">Pseudocode</a></li>
                        </ul>
                        <div id="ta_div_statusErklaerung">
                            <h3>Initialisierung</h3>
                            <!--<p>Im nächsten Schritt wird festgestellt, ob das Briefträgerproblem auf dem Graphen lösbar ist. Dazu muss der Graph stark zusammenhängend sein. D.h. von jedem Knoten muss jeder andere Knoten erreichbar sein.</p>-->
                            <p>Zuerst werden alle Knoten gelöscht, die keine Eingangs- und Ausgangskanten besitzen. Diese isolierten Knoten haben keine Auswirkung auf den weiteren Verlauf des Algorithmus.</p>
                            <p>Kliche auf den "Nächster Schritt"-Button um den Algorithmus zu starten.</p>
                        </div>
                        <div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                            <p class="pseudocode" id="ta_p_begin">BEGIN</p>
                            <p class="pseudocode" id="ta_p_l">  1. Prüfe ob der das Problem lösbar ist.</p>
                            <p class="pseudocode" id="ta_p_2">  2. Bestimme alle Knoten, die ungleiche Anzahl von Eingeh- und Ausgehkanten besitzen.</p>
                            <p class="pseudocode" id="ta_p_3">  3. Kürzeste Wege</p>
                            <p class="pseudocode" id="ta_p_4">  4. Finde Matching</p>
                            <p class="pseudocode" id="ta_p_5">  5. Füge Kanten hinzu</p>
                            <p class="pseudocode" id="ta_p_6">  6. Finde die Eulertour</p>
                            <p class="pseudocode" id="ta_p_end">END</p>
<!--                            <h3>Status der Variablen:</h3>
                            <table class="algoInformationen">
                                <tr>
                                    <th class="algoInfoTH"><span>i</span></th>
                                    <th class="algoInfoTH"><span>d(u)</span></th>
                                    <th class="algoInfoTH"><span>d(v)</span></th>
                                    <th class="algoInfoTH"><span>l(u,v)</span></th>
                                </tr>
                                <tr>
                                    <td id="ta_td_vari" class="algoInfoTD"></td>
                                    <td id="ta_td_vardu" class="algoInfoTD"></td>
                                    <td id="ta_td_vardv" class="algoInfoTD"></td>
                                    <td id="ta_td_varluv" class="algoInfoTD"></td>
                                </tr>
                            </table>-->
                        </div>
                    </div>
                </div>
            </div>
            <div title="Algorithmus ausführen" class="tabIntroDialog">
                <h2>Den Briefträger-Algorithmus ausführen</h2>
                <p>In diesem Schritt sehen wir, wie der Algorithmus arbeitet.</p>
                <p>Rechts vom Graph kannst du die Ausführung kontrollieren.</p>
            </div>
            <div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird der Algorithmus abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>
        <div id="tab_ti">
            <div id="ti_div_Einfuehrungstext">
                <h1>Briefträgerproblem</h1>
                <p>
                    Gegeben ist ein gerichteter und gewichteter Graph G. Das Briefträgerproblem besteht darin, einen Rundgang im Graphen zu finden, sodass alle Kanten mindesten einmal
                    benutzt werden und die Summe der Kantengewichte des Rundgangs (Kosten des Rundgangs) minimal ist. Ein Beispiel für dieses Problems ist ein Postbote, der alle Straßen
                    einer Stadt ablaufen muss und wieder zum Startpunkt zurückkehrt. Dabei will er eine möglichst kurze Distanz zurücklegen.
                </p>
                <h1>Idee des Algorithmen</h1>
                <p>
                    Angenommen es existieren keine isolierten Knoten. Das Problem ist genau dann lösbar, wenn der Graph stark zusammenhängend ist (jeder Knoten von jedem Knoten aus erreichbar) und keine negativen Kreise existieren. .
                    Das Problem lässt sich auf das Bestimmen einer Eulertour im Graphen zurückführen. Falls es eine Eulertour im Graphen gibt,
                    so ist diese Tour das optimale Ergebnis, da jede Kante genau einmal benutzt wird. Im anderen Fall müssen einige Kanten mehrmals benutzt werden. Diese Situation lässt sich modellieren, indem
                    wir zusätzliche Kanten in den Graphen einfügen, die mehrmals benutzten Kanten repräsentieren (mit dem gleichen Gewicht wie die originale Kante). Dann besitzt der Rundgang die gleichen Kosten, wie
                    die Eulertour im neuen Graphen. Das Problem besteht jetzt darin, die mehrfach benutzten Kanten im minimalen Rundgang zu finden.
                </p>
                <p> Ein Theorem der Graphentheorie besagt, dass es genau dann eine Eulertour im Graphen gibt, wenn bei allen Knoten im Graphen der Eingangsgrad mit dem Ausgangsgrad übereinstimmt.
                    Also reicht es aus, wenn wir zusätzliche Pfade in den Graphen einfügen, sodass bei allen Knoten im Graphen der Eingangsgrad mit dem Ausgangsgrad übereinstimmt.
                    Welche Pfade genau eingefügt werden, wird im Matching-Schritt des Algorithmen festgestellt. Die Summe der Kantengewichte der Pfade sollte minimal sein.
                </p>
                <p>
                    Nachdem sichergestellt wurde, dass der Graph eine Eulertour besitzt, muss diese nur gefunden werden. Dies erfolgt mit einem geeigneten Algorithmus, wie z.B. dem Hierholzer-Algorithmus.
                    Die Kosten des optimalen Rundgangs werden durch die Summe aller Kantengewichte der Eulertour bestimmt.
                </p>
                <h1>Kürzeste Wege</h1>
                <p>
                    Für den Matching-Schritt des Algorithmen benötigt man die Abstände und die kürzesten Wege zwischen je zwei Knoten des Graphen.
                    Um die kürzesten Wege bestimmen, wird der Algorithmus von Floyd-Warshall benutzt.
                    <!--Dieser Algorithmus berechnet im Gegensatz zu Bellman-Ford-Algorithmus die kürzesten Wege zwischen allen Knoten. -->
                    Weitere Erklärungen zu diesem Algorithmus können hier gefunden werden.
                </p>
                <h1>Matching</h1>
                <p>
                    Durch Einfügen zusätzlicher Pfade wollen wir erreichen, dass bei allen Knoten im Graphen der Eingangsgrad mit dem Ausgangsgrad übereinstimmt. Dann existiert eine Eulertour im Graphen.
                    Wir bezeichnen mit der Graddifferenz die Differenz zwischen dem Ausgangs- und dem Eingangsgrad eines Knotens. Um zu bestimmen welche Pfade wir einfügen, muss eine Zuordnung von Knoten
                    mit negativer Graddifferenz zu den Knoten mir positiver Graddifferenz erfolgen. Dabei bestimmt die Graddifferenz die Anzahl der neuen Pfade, die in diesem Knoten anfangen bzw. enden müssen.
                    Ein Pfad vergrößert die Graddifferenz des Startknotens um eins und verringert die Graddifferenz des Zielknotens um eins.
                </p>
                <p>
                    Das Gewicht der zusätzlichen Pfade sollte minimal sein. Um dieses Ziel zu erreichen könnte man einen neuen bipartiten Graphen erstellen.
                    Knoten mit Graddifferenz ungleich 0 werden in zwei Partitionen geteilt (negative und positive Graddifferenzen).
                    Abhängig von der Graddifferenz eines Knotens, können mehrere Kopien des Knotens im bipartiten Graph vorkommen. Z.B. existieren von einem Knoten mit Graddifferenz 3 genau 3 Kopien im Graphen.
                    Das Gewicht einer Kante stellt die Länge des kürzesten Pfades dar. Damit erhalten wir einen vollständigen bipartiten Graph. Wir wenden einen Algorithmus zur Lösung von gewichteten Matchings auf diesen Graphen.
                    Ein Algorithmus zur Lösung von gewichteten Matchings wird hier vorgestellt. Damit erhalten wir die optimale Zuordnung und können die neuen Pfade einfügen.
                    Die Kanten der Pfade repräsentieren die Kanten des optimalen Rundgangs, die mehrmals benutzt werden.
                </p>
                <h1>Eulertour</h1>
                <p>
                    Nach dem Einfügen von zusätzlichen Pfaden ist sichergestellt, dass es eine Eulertour im Graphen existiert. Um diese zu finden, kann der Algorithmus von Hierholzer verwendet werden.
                    Dieser startet mit einem beliebigen Knoten und folgt den Kanten bis man wieder an den Startpunkt gelangt. Falls noch unbenutzte Kanten existieren, wiederholt man die Prozedur
                    mit einem Knoten auf der bereits gefundenen Tour und fügt die neue Tour in die alte ein. Dies wird wiederholt, bis alle Kanten benutzt wurden. Eine detailierte Beschreibung des Algorithmen kann hier gefunden werden.
                </p>
                <h1>Was nun?</h1>
                <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                    <h3>Einen Graph erstellen und den Algorithmus durchspielen</h3>
                    <button id="ti_button_gotoDrawGraph">Graph erstellen und daran den Algorithmus testen</button>
                    <button id="ti_button_gotoAlgorithm">Algorithmus am fertigen Beispiel ausprobieren</button>
                </div>
                <div class="Entscheidungsweg" id="ti_div_EntscheidungRight">
                    <h3>Sein Wissen an den Forschungsaufgaben testen</h3>
                    <button id="ti_button_gotoFA1">Forschungsaufgabe: Wie würde der Algorithmus entscheiden?</button><br>
                    <button id="ti_button_gotoFA2">Forschungsaufgabe: Wie ist die optimale Sortierung der Knoten?</button>
                </div>
            </div>
        </div>
        <div id="tab_tf1">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tf1_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/startknoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Startknoten, von dem aus die Entfernungen und günstigsten Wege berechnet werden.</span></td>
                                </tr>
                                <tr class="LegendeZeileClickable" id="tf1_tr_LegendeClickable" title="Klicke zum Ein-/Ausblenden">
                                    <td class="LegendeTabelle"><img src="img/markierteKante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>"Vorgängerkante", die der günstigste Weg zum Knoten benutzt.</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tf1_div_statusWindow" class="statusWindow">
                    <h2 class="">Prüfe dein Wissen: Wie würde der Algorithmus entscheiden?</h2>
<!--                    <select id="tf1_select_aufgabeGraph" name="Wähle einen Graphen">
                        <option selected>Selbsterstellter Graph</option>
                        <option>Standardbeispiel</option>
                        <option>Negativer Kreis</option>
                        <option>Positiver Kreis</option>
                    </select>-->
                    <div id="tf1_div_abspielbuttons">
                    </div>
                    <div id="tf1_div_statusTabs">
                         <ul>
                            <li><a href="#tf1_div_statusErklaerung">Erklärung</a></li>
                            <li><a href="#tf1_div_statusPseudocode">Pseudocode</a></li>
                        </ul>
                        <div id="tf1_div_statusErklaerung">
                            <h2>In diesem Teil kann man sein Wissen testen: Wie würde der Algorithmus entscheiden?</h2>
                            <p>
                                Der Algorithmus wird normal ausgeführt, stoppt aber an einigen Stellen.
                                Du musst dann vorhersagen, wie der Algorithmus entscheiden würde.
                            </p>
                            <p>Tipp: Vorher nochmals die Beschreibung des Algorithmus durchlesen.</p>
                        </div>
                        <div class="PseudocodeWrapper" id="tf1_div_statusPseudocode">
                            <p class="pseudocode" id="tf1_p_l1">BEGIN</p>
                            <p class="pseudocode" id="tf1_p_l2">  d(v[1]) &larr; 0</p>
                            <p class="pseudocode" id="tf1_p_l3">  FOR j = 2,..,n DO</p>
                            <p class="pseudocode" id="tf1_p_l4">    d(v[j]) &larr; &#8734;</p>
                            <p class="pseudocode" id="tf1_p_l5">  FOR i = 1,..,(|V|-1) DO</p>
                            <p class="pseudocode" id="tf1_p_l6">    FOR ALL (u,v) aus E DO</p>
                            <p class="pseudocode" id="tf1_p_l7">      d(v) &larr; min(d(v), d(u)+l(u,v))</p>
                            <p class="pseudocode" id="tf1_p_l8">  FOR ALL (u,v) aus E DO</p>
                            <p class="pseudocode" id="tf1_p_l9">    IF d(v) > d(u) + l(u,v) DO</p>
                            <p class="pseudocode" id="tf1_p_l10">     Meldung: "Negativer Kreis"</p>
                            <p class="pseudocode" id="tf1_p_l11">END</p>
                            <h3>Status der Variablen:</h3>
                            <table class="algoInformationen">
                                <tr>
                                    <th class="algoInfoTH"><span>i</span></th>
                                    <th class="algoInfoTH"><span>d(u)</span></th>
                                    <th class="algoInfoTH"><span>d(v)</span></th>
                                    <th class="algoInfoTH"><span>l(u,v)</span></th>
                                </tr>
                                <tr>
                                    <td id="tf1_td_vari" class="algoInfoTD"></td>
                                    <td id="tf1_td_vardu" class="algoInfoTD"></td>
                                    <td id="tf1_td_vardv" class="algoInfoTD"></td>
                                    <td id="tf1_td_varluv" class="algoInfoTD"></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            <div title="Forschungsaufgabe 1" class="tabIntroDialog">
                <h2>In diesem Teil kann man sein Wissen testen: Wie würde der Algorithmus entscheiden?</h2>
                <p>
                    Der Algorithmus wird normal ausgeführt, stoppt aber an einigen Stellen. 
                    Du musst dann vorhersagen, wie der Algorithmus entscheiden würde.
                </p>
                <p>Tipp: Vorher nochmals die Beschreibung des Algorithmus durchlesen.</p>
            </div>
            <div id="tf1_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>
        <div id="tab_tf2">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tf2_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/startknoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Startknoten, von dem aus die Entfernungen und günstigsten Wege berechnet werden.</span></td>
                                </tr>
                                <tr class="LegendeZeileClickable" id="tf2_tr_LegendeClickable" title="Klicke zum Ein-/Ausblenden">
                                    <td class="LegendeTabelle"><img src="img/markierteKante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>"Vorgängerkante", die der günstigste Weg zum Knoten benutzt.</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tf2_div_statusWindow" class="statusWindow">
                    <h2>Finde selber einen Rundweg</h2>
                    <div id="tf2_div_Abspielbuttons"></div>
<!--                    <select id="tf2_select_aufgabeGraph" name="Wähle einen Graphen">
                        <option selected>Selbsterstellter Graph</option>
                        <option>Standardbeispiel</option>
                        <option>Negativer Kreis</option>
                        <option>Positiver Kreis</option>
                    </select>-->
                    <div id="tf2_div_statusErklaerung">
                        <h3>Klicke auf eine beliebige Kante, um mit der Aufgabe zu beginnen.</h3>
                        <p>Klicke danach in der Reihenfolge auf die Kanten, in der Sie der Postbote ablaufen soll.</p>
                        <p>Der Rundweg endet, wenn alle Kanten abgelaufen sind und der Postbote zum Anfangsknotenzurückkehrt.</p>
                    </div>
                    <div id="tf2_div_Frage">
                    </div>
                    <div id="tf2_div_Antworten">
                    </div>
                </div>
            </div>
            <div title="Forschungsaufgabe 2" class="tabIntroDialog">
                <h2>Klicke auf eine beliebige Kante, um mit der Aufgabe zu beginnen.</h2>
                <p>Klicke danach in der Reihenfolge auf die Kanten, in der Sie der Postbote ablaufen soll.</p>
                <p>Der Rundweg endet, wenn alle Kanten abgelaufen sind und der Postbote zum Anfangsknotenzurückkehrt.</p>
            </div>
            <div id="tf2_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>
        <div id="tab_tw">
            <div id="tw_Accordion">
                <h3>Wie sieht der (Pseudo-)Code des Algorithmus aus?</h3>
                <div><pre><code>

                    </code></pre>
                    <hr><pre><code>

                    </code></pre>
                </div>
                <h3>Wie schnell ist der Algorithmus?</h3>
                <div>
                    <p>
                        Die Laufzeit des Algorithmen hängt von der Laufzeit der benutzten Unteralgorithmen. Diese sind:
                    <li>
                        <ul>Kürzeste-Wege-Algorithmus </ul>
                        <ul>Algorithmus zur Bestimmung von optimalen zusätzlichen Pfaden (z.B Algorithmus zur Bestimmung von gewichteten Matchings)</ul>
                        <ul>Algorithmus zur Bestimmung von Eulertouren</ul>
                    </li>
                    Für alle diese Probleme existieren polynomielle Algorithmen. Demzufolge ist das Briefträgerproblem ebenfalls in polynomieller Zeit lösbar.
                    Die Implementierung auf dieser Seite benutzt den Floyd-Warshall-Algorithmus zur Bestimmung von kürzesten Wegen, ungarische Methode für die Lösung des Matching-Problems
                    und den Hierholzer-Algorithmus zum Finden der Eulertour.
                    </p>
                </div>
                <h3>Wie beweist man, dass der Algorithmus stets ein korrektes Ergebnis berechnet?</h3>
                <div>
                    <p>
                        
                    </p>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <p class="Disclaimer">
            IDP Projekt von Ruslan Zabrodin am Lehrstuhl M9 der Technischen Universität München. 2015 | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Disclaimer und Rechtshinweise</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">Impressum</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Anregungen</a>
        </p>
    </footer>
</body>