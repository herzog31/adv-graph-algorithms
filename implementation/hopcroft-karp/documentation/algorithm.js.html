<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: algorithm.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: algorithm.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Instanz des Hopcroft-Karp Algorithmus, erweitert die Klasse CanvasDrawer
 * @constructor
 * @augments CanvasDrawer
 * @param {BipartiteGraph} p_graph Graph, auf dem der Algorithmus ausgeführt wird
 * @param {Object} p_canvas jQuery Objekt des Canvas, in dem gezeichnet wird.
 * @param {Object} p_tab jQuery Objekt des aktuellen Tabs.
 */
function HKAlgorithm(p_graph,p_canvas,p_tab) {
    CanvasDrawer.call(this,p_graph,p_canvas,p_tab); 
    //console.log(p_graph.getDescriptionAsString());
    /**
     * Convenience Objekt, damit man den Graph ohne this ansprechen kann.
     * @type Graph
     */
    var graph = this.graph;
    /**
     * Convenience Objekt, damit man das Canvas ohne this. ansprechen kann.
     * @type Object
     */
    var canvas = p_canvas;
    /**
     * ID des Intervals, der für das "Vorspulen" genutzt wurde.
     * @type Number
     */
    var fastForwardIntervalID = null;
    /**
     * Der Algorithmus kann in verschiedenen Zuständen sein, diese Variable 
     * speichert die ID des aktuellen Zustands.&lt;br>
     * Siehe Dokumentation bei der Funktion nextStepChoice
     * @type Number
     */
    var statusID = 0;
    /**
     * Closure Variable für dieses Objekt
     * @type HKAlgorithm
     */
    var algo = this;
    /**
     * Enthaelt alle Kanten, die zu aktuellem Zeitpunkt zum Matching gehoeren.
     * Keys: KantenIDs Value: Kanten
     * @type Object
     */
    var matching = new Object();
    /*
    * Repraesentiert den Augmentierungsgraphen.
    * @type Object
    * */
    var bfsEdges = new Object();
    /*
     * Die Laenge des kuerzesten verbessernden Pfades in der aktuellen Iteration.
     * @type Number
     * */
    var shortestPathLength = 0;
    /*
    * Enthaelt die Matching-Partner der Knoten.
    * Keys: KnotenIDs Value: Knoten
    * @type Object
    * */
    var matched = new Object();
    /*
    * Enthaelt die disjunkten augmentierenden Pfade der aktuellen Iteration.
    * Die Pfade sehen wie folgt aus: v1,e1,v2,...,en-1,vn.
    * Dabei bezeichnen vi Knoten und ei Kanten
    * @type Array
    * */
    var disjointPaths = new Array();
    /*
    * Der Pfad, der aktuell bearbeitet wird.
    * @type Number
    * */
    var currentPath = 0;
    /*
    * Alle benoetigten Information zur Wiederherstellung der vorangegangenen Schritte werden hier gespeichert.
    * @type Array
    * */
    var history = new Array();
    /**
     * Zählt die Phasen / Runden.
     * @type Number
     */
    var iteration = 0;
    /**
     * Wird fuer die Anzeige des Matchings am Ende des Algorithmus benoetigt.
     * @type Boolean
     */
    var toggleMatchButton = true;
    /**
     * Gibt den Kontext des Ausgabefensters an.
     * @type String
     */
    var st = "ta";
    /**
     * Gibt das Statusausgabefenster an.
     * @type String
     */
    var statusErklaerung = "#"+st+"_div_statusErklaerung";
    /*
    * Hier werden die Statuskonstanten definiert
    * */
    const ALGOINIT = 0;
    const BEGIN_ITERATION = 1;
    const END_ITERATION = 2;
    const NEXT_AUGMENTING_PATH = 3;
    const UPDATE_MATCHING = 4;
    const GRAY_PATH = 5;
    const END_ALGORITHM = 6;

    /**
     * Startet die Ausführung des Algorithmus.
     * @method
     */
    this.run = function() {
        this.initCanvasDrawer();
        // Die Buttons werden erst im Javascript erstellt, um Problemen bei der mehrfachen Initialisierung vorzubeugen.
        $("#"+st+"_div_abspielbuttons").append('&lt;button id="'+st+'_button_Zurueck">'+LNG.K('algorithm_btn_prev')+'&lt;/button>'
                        +'&lt;button id="'+st+'_button_1Schritt">'+LNG.K('algorithm_btn_next')+'&lt;/button>'
                        +'&lt;button id="'+st+'_button_vorspulen">'+LNG.K('algorithm_btn_frwd')+'&lt;/button>'
                        +'&lt;button id="'+st+'_button_stoppVorspulen">'+LNG.K('algorithm_btn_paus')+'&lt;/button>');
        $("#"+st+"_button_stoppVorspulen").hide();
        $("#"+st+"_button_Zurueck").button({icons:{primary: "ui-icon-seek-start"}, disabled: true});
        $("#"+st+"_button_1Schritt").button({icons:{primary: "ui-icon-seek-end"}, disabled: false});
        $("#"+st+"_button_vorspulen").button({icons:{primary: "ui-icon-seek-next"}, disabled: false});
        $("#"+st+"_button_stoppVorspulen").button({icons:{primary: "ui-icon-pause"}});
        $("#"+st+"_div_statusTabs").tabs();
        $(".marked").removeClass("marked");
        $("#"+st+"_tr_LegendeClickable").removeClass("greyedOutBackground");
        this.registerEventHandlers();
        this.needRedraw = true;
    };

    /**
     * Beendet die Ausführung des Algorithmus.
     * @method
     */
    this.destroy = function() {
        this.stopFastForward();
        this.destroyCanvasDrawer();
        this.deregisterEventHandlers();
    };

    /**
     * Beendet den Tab und startet ihn neu
     * @method
     */
    this.refresh = function() {
        this.destroy();
        var algo = new HKAlgorithm($("body").data("graph"),$("#"+st+"_canvas_graph"),$("#tab_"+st));
        $("#tab_"+st).data("algo",algo);
        algo.run();
    };

    /**
     * Zeigt and, in welchem Zustand sich der Algorithmus im Moment befindet.
     * @returns {Number} StatusID des Algorithmus
     */
    this.getStatusID = function() {
        return statusID;
    };

    /**
     * Registriere die Eventhandler an Buttons und canvas&lt;br>
     * Nutzt den Event Namespace ".HKAlgorithm"
     * @method
     */
    this.registerEventHandlers = function() {
//        canvas.on("mousemove.HKAlgorithm",function(e) {algo.canvasMouseMoveHandler(e);});
        $("#"+st+"_button_1Schritt").on("click.HKAlgorithm",function() {algo.singleStepHandler();});
        $("#"+st+"_button_vorspulen").on("click.HKAlgorithm",function() {algo.fastForwardAlgorithm();});
        $("#"+st+"_button_stoppVorspulen").on("click.HKAlgorithm",function() {algo.stopFastForward();});
        $("#"+st+"_tr_LegendeClickable").on("click.HKAlgorithm",function() {algo.changeVorgaengerVisualization();});
        $("#"+st+"_button_Zurueck").on("click.HKAlgorithm",function() {algo.previousStepChoice();});
    };

    /**
     * Entferne die Eventhandler von Buttons und canvas im Namespace ".HKAlgorithm"
     * @method
     */
    this.deregisterEventHandlers = function() {
        canvas.off(".HKAlgorithm");
        $("#"+st+"_button_1Schritt").off(".HKAlgorithm");
        $("#"+st+"_button_vorspulen").off(".HKAlgorithm");
        $("#"+st+"_button_stoppVorspulen").off(".HKAlgorithm");
        $("#"+st+"_tr_LegendeClickable").off(".HKAlgorithm");
        $("#"+st+"_button_Zurueck").off(".HKAlgorithm");
    };

    /**
     * Wird aufgerufen, wenn der "1 Schritt" Button gedrückt wird.
     * @method
     */
    this.singleStepHandler = function() {
        this.nextStepChoice();
    };

    /**
     * "Spult vor", führt den Algorithmus mit hoher Geschwindigkeit aus.
     * @method
     */
    this.fastForwardAlgorithm = function () {
        $("#"+st+"_button_vorspulen").hide();
        $("#"+st+"_button_stoppVorspulen").show();
        $("#"+st+"_button_1Schritt").button("option", "disabled", true);
        $("#"+st+"_button_Zurueck").button("option", "disabled", true);
        var geschwindigkeit = 200;	// Geschwindigkeit, mit der der Algorithmus ausgeführt wird in Millisekunden

        fastForwardIntervalID = window.setInterval(function () {
            algo.nextStepChoice();
        }, geschwindigkeit);
    };

    /**
     * Stoppt das automatische Abspielen des Algorithmus
     * @method
     */
    this.stopFastForward = function() {
        $("#"+st+"_button_vorspulen").show();
        $("#"+st+"_button_stoppVorspulen").hide();
        $("#"+st+"_button_1Schritt").button("option", "disabled", false);
        $("#"+st+"_button_Zurueck").button("option", "disabled", false);
        window.clearInterval(fastForwardIntervalID);
        fastForwardIntervalID = null;
    };

    /**
    * In dieser Funktion wird der nächste Schritt des Algorithmus ausgewählt.
    * Welcher das ist, wird über die Variable "statusID" bestimmt.&lt;br>
    *  @method
    */
    this.nextStepChoice = function () {
        this.addReplayStep();
        switch (statusID) {
            case ALGOINIT:
                this.initialize();
                break;
            case BEGIN_ITERATION:
                this.beginIteration();
                break;
            case END_ITERATION:
                this.endIteration();
                break;
            case NEXT_AUGMENTING_PATH:
                this.highlightPath(disjointPaths[currentPath]);
                break;
            case UPDATE_MATCHING:
                this.augmentMatching(disjointPaths[currentPath]);
                break;
            case GRAY_PATH:
                this.hidePath(disjointPaths[currentPath]);
                break;
            case END_ALGORITHM:
                this.endAlgorithm();
                break;
            default:
                //console.log("Fehlerhafte StatusID.");
                break;
        }
        this.needRedraw = true;
    };

    /*
    * Mit Hilfe der Breitensuche wird ein Augmentationsgraph aufgebaut, der die kuerzesten Augmentationswege enthaelt.
    * @param {Object} superNode   Startknoten fuer die Breitensuche.
    * @method
    * */
    var bfs = function (superNode) {
        //Initialize
        var freeNodeFound = false;
        var emptyLayer = false;
        var evenLayer = {};
        var oddLayer = {};
        var examined = {};
        shortestPathLength = 0;
        for (var knotenID in graph.nodes) {
            examined[knotenID] = false;
            bfsEdges[knotenID] = {};
        }
        for (var free in superNode) {
            evenLayer[free] = superNode[free];
        }
        //Iterate
        while (!freeNodeFound &amp;&amp; !emptyLayer) {
            shortestPathLength++;
            for (n in evenLayer) {
                var node = evenLayer[n];
                examined[node.getNodeID()] = true;
                //find all adjacent edges
                var edges = node.getOutEdges();
/*                var inEdges = node.getInEdges();
                for (var e in inEdges) {edges[e] = inEdges[e];}*/
                //try all the found edges
                for (var e in edges) {
                    var edge = edges[e];
                    var adj = edge.getTargetID();
                    if (!examined[adj]) {
                        bfsEdges[node.getNodeID()][adj] = edge;
                        if(!oddLayer.hasOwnProperty(adj)) oddLayer[adj] = graph.nodes[adj]; //if not already in the oddLayer then insert
                        if (!matched[adj]) freeNodeFound = true; // if unmatched we found the shortest path
                    }
                }
            }
            if (freeNodeFound) {
                for (var ind in evenLayer) {
                    var node = evenLayer[ind];
                    var children = bfsEdges[node.getNodeID()];
                    for (n in children) {
                        if (matched[n]) {
                            delete children[n];
                        }
                    }
                }
            }
            else if (!Object.keys(oddLayer).length) { // oddLayer is empty
                emptyLayer = true;
                shortestPathLength = 0;
            }
            else {
                evenLayer = {};
                for(var n in oddLayer){
                    var node = oddLayer[n];
                    var partner = matched[node.getNodeID()];
                    var edge = graph.edges[graph.getEdgeBetween(partner,node)];
                    bfsEdges[node.getNodeID()][partner.getNodeID()] = edge;
                    evenLayer[partner.getNodeID()] = partner;
                    examined[node.getNodeID()] = true;
                }
                oddLayer = {};
                shortestPathLength++;
            }
        }
    };

    /*
    * Mittels der Tiefensuche wird nach knotendisjunkten Augmantationswegen gesucht. Dabei wird der Augmentierungsgraph aus der Bfs-Phase verwendet.
    * @param {Object} superNode   Startknoten fuer die Tiefensuche
    * @method
    * */
   var dfs = function(superNode){
       var dfsStack = [];
       for (var node in superNode) {
           var foundAugmentingPath = recursiveDfs(superNode[node], dfsStack);
           if (foundAugmentingPath){ //delete the edges of nodes in stack from the graph to ensure disjunct paths
               for (var i = 0; i &lt; dfsStack.length; i=i+2) { //iterate only over the nodes in path
                   var curr = dfsStack[i];
                   var parents = curr.getInEdges();
                   for (var e in parents) {
                       var pid = parents[e].getSourceID();
                       delete bfsEdges[pid][curr.getNodeID()];
                   }
                   parents = curr.getOutEdges();
                   for (var e in parents) {
                       var pid = parents[e].getTargetID();
                       delete bfsEdges[pid][curr.getNodeID()];
                   }
               }
               delete superNode[node];
               disjointPaths.push(dfsStack);
           }
           dfsStack = [];
       }
   };
    /*
    * Rekursives Unterprogramm, das fuer die Tiefensuche benutzt wird.
    * @param {Object} node   Der aktuelle Knoten
    * @param {Object} stack   Der aufgebaute Stack
    * @method
    * */
   var recursiveDfs = function (node, stack) {
        stack.push(node);
        if (!matched[node.getNodeID()] &amp;&amp; stack.length>1) return true;
        else {
            var children = bfsEdges[node.getNodeID()];
            for (var c in children) {
                stack.push(children[c]);
                if (recursiveDfs(graph.nodes[c], stack)) {
                    return true;
                }
                stack.pop();
            }
        }
        stack.pop();
        return false;
    };

    /*
     * Methoden fuer die Visualisierung.
     * Das Layout und Aussehen von Knoten und Kanten wird hier festgelegt.
     * */
    var setEdgeMatched = function(edge){
        edge.setLayout("lineColor", "green");
        edge.setLayout("lineWidth", global_Edgelayout.lineWidth*1.3);
    };
    var setEdgeNotMatched = function(edge){
        edge.setLayout("lineColor", global_Edgelayout.lineColor);
        edge.setLayout("lineWidth", global_Edgelayout.lineWidth);
    };
    var setNodeMatched = function(node){
        node.setLayout('fillStyle', const_Colors.NodeFillingHighlight);
        node.setLayout('borderColor',global_NodeLayout.borderColor);
    };
    var setNodeNotMatched = function(node){
        node.restoreLayout();
    };
    var highlightNode = function(node){
        node.setLayout('borderColor',"Navy");
        //node.setLayout('borderColor',const_Colors.NodeBorderHighlight);
        node.setLayout('borderWidth',global_NodeLayout.borderWidth*1.5);
    };
    var highlightEdge = function(edge){
        edge.setLayout("lineWidth", global_Edgelayout.lineWidth*2.9);
    };
    var highlightFreeNode = function(node){
        node.setLayout('borderWidth',global_NodeLayout.borderWidth * 2);
        node.setLayout('fillStyle',"SteelBlue ");
    };
    var hideEdge = function(edge) {
        if(matching[edge.getEdgeID()]){
            edge.setLayout("lineWidth", global_Edgelayout.lineWidth * 0.6);
        }
        else edge.setLayout("lineWidth", global_Edgelayout.lineWidth * 0.3);
    };
    var hideNode = function(node){
        node.setLayout('fillStyle',"DarkGray");
        node.setLayout('borderWidth',global_NodeLayout.borderWidth);
        node.setLayout('borderColor',"Gray");
    };

    /**
     * Initialisiere den Algorithmus.
     * @method
     */
    this.initialize = function () {
        this.beginIteration();
        $("#"+st+"_button_Zurueck").button("option", "disabled", false);
    };

    /*
     * Jede neue Iteration beginnt mit dieser Methode. Es werden Breitensuche und Tiefensuche ausgefuehrt, um die kuerzesten Wege zu finden.
     * @method
     * */
    this.beginIteration = function () {
        iteration++;
        disjointPaths = [];
        currentPath = 0;
        shortestPathLength = 0;
        // finde alle freien Knoten in der U-Partition
        var superNode = {};
        for (var n in graph.unodes) {
            var node = graph.unodes[n];
            if(!this.isMatched(node))superNode[node.getNodeID()] = node;
        }
        //fuehre Breiten- und Tiefensuche aus
        bfs(superNode);
        dfs(superNode);
        //restore Layouts
        for(var n in graph.nodes){
            var node = graph.nodes[n];
            if(this.isMatched(node)) setNodeMatched(node);
            else setNodeNotMatched(node);
        }
        for(var e in graph.edges){
            setEdgeNotMatched(graph.edges[e]);
        }
        for(var e in matching){
            setEdgeMatched(graph.edges[e]);
        }
        if(shortestPathLength > 0){
            statusID = NEXT_AUGMENTING_PATH;
            $(statusErklaerung).html('&lt;h3>'+iteration+'. '+LNG.K('textdb_text_iteration')+'&lt;/h3>'
                + "&lt;h3> "+LNG.K('textdb_msg_begin_it')+"&lt;/h3>"
                + "&lt;p>"+LNG.K('textdb_msg_begin_it_1')+"&lt;p>"
                + "&lt;p>"+LNG.K('textdb_msg_path_shortest')+ shortestPathLength + "&lt;/p>"
                + "&lt;p>"+LNG.K('textdb_msg_begin_it_2')+"&lt;p>"
                + "&lt;p>"+LNG.K('textdb_msg_begin_it_3')+"&lt;p>");
        }
        else{
            statusID = END_ALGORITHM;
            $(statusErklaerung).html("&lt;h3> "+LNG.K('textdb_msg_end_algo')+"&lt;/h3>"
                + "&lt;p>"+LNG.K('textdb_msg_end_algo_1')+"&lt;/p>");
        }
    };
    /*
     * Der aktuelle Augmentationsweg wird hervorgehoben.
     * @param {Object} path   Der aktuelle Augmentationsweg
     * @method
     * */
    this.highlightPath = function(path){
        //alle Kanten ein wenig in den Hintergrund
        //for(var e in graph.edges) graph.edges[e].setLayout("lineWidth", global_Edgelayout.lineWidth * 0.9);
        //hervorheben des Augmentationsweges(Knoten und Kanten)
        for(var n = 0; n &lt; path.length; n=n+2){
            var node = path[n];
            highlightNode(node);
            if(n &lt; path.length - 1){
                var edge = path[n+1];
                highlightEdge(edge);
            }
        }
        //die freien Knoten hervorheben(erster und letzter Knoten auf dem Weg)
        highlightFreeNode(path[0]);
        highlightFreeNode(path[path.length-1]);

        //statuserklaerung
        $(statusErklaerung).html('&lt;h3>'+iteration+'. '+LNG.K('textdb_text_iteration')+'&lt;/h3>'
            + "&lt;h3> "+LNG.K('textdb_msg_path_highlight')+"&lt;/h3>"
            + "&lt;p>"+LNG.K('textdb_msg_path_shortest')+ shortestPathLength + "&lt;/p>"
            + "&lt;p> "+LNG.K('textdb_msg_path_highlight_1')+"&lt;p>"
            + "&lt;p> "+LNG.K('textdb_msg_path_highlight_2')+"&lt;p>");
        statusID = UPDATE_MATCHING;
    };

    /*
     * Das Matching wird durch den aktuellen Augmentationsweg verbessert.
     * Die Kanten des aktuellen Augmentationsweges werden vertauscht.
     * @param {Object} path   Der aktuelle Augmentationsweg
     * @method
     * */
    this.augmentMatching = function(path){
        //iteriere ueber alle Kanten auf dem Augmentierungsweg
        for (var i = 1; i &lt; path.length-1; i = i + 2) {
            var edge = path[i];
            //vertausche die Kanten
            if(matching[edge.getEdgeID()]){
                delete matching[edge.getEdgeID()];
                setEdgeNotMatched(edge);
                highlightEdge(edge);
            }
            else{
                matching[edge.getEdgeID()] = edge;
                matched[path[i-1].getNodeID()] =  path[i+1];
                matched[path[i+1].getNodeID()] =  path[i-1];
                setEdgeMatched(edge);
                highlightEdge(edge);
            }
            setNodeMatched(path[i-1]);
        }
        setNodeMatched(path[path.length-1]);
        //statuserklaerung
        statusID = GRAY_PATH;
        $(statusErklaerung).html('&lt;h3>'+iteration+'. '+LNG.K('textdb_text_iteration')+'&lt;/h3>'
            + "&lt;h3> "+LNG.K('textdb_msg_update')+"&lt;/h3>"
            + "&lt;p>"+LNG.K('textdb_msg_update_1')+ "&lt;/p>"
            + "&lt;p>"+LNG.K('textdb_msg_update_2')+ "&lt;/p>");
    };

    /*
     * Die auf dem Augmentationsweg benutzten Knoten und inzidenten Kanten werden ausgeblendet.
     * @param {Object} path   Der aktuelle Augmentationsweg
     * @method
     * */
    this.hidePath = function(path){
        for (var i = 0; i &lt; path.length; i = i + 2) {
            var node = path[i];
            hideNode(node);
            // gray out OutEdges
            var edges = node.getOutEdges();
            for(var e in edges){
                hideEdge(edges[e]);
            }
            // gray out InEdges
            edges = node.getInEdges();
            for(var e in edges){
                hideEdge(edges[e]);
            }
        }
        currentPath++;
        //statuserklaerung
        if(currentPath &lt; disjointPaths.length){
            statusID = NEXT_AUGMENTING_PATH;
        }
        else statusID = END_ITERATION;
        $(statusErklaerung).html('&lt;h3>'+iteration+'. '+LNG.K('textdb_text_iteration')+'&lt;/h3>'
            + "&lt;h3> "+LNG.K('textdb_msg_gray')+"&lt;/h3>"
            + "&lt;p>"+LNG.K('textdb_msg_gray_1')+ "&lt;/p>");
    };

    /*
    * Beendet die Iteration.
    * @method
    * */
    this.endIteration = function(){
        statusID = BEGIN_ITERATION;
        //statuserklaerung
        $(statusErklaerung).html('&lt;h3>'+iteration+'. '+LNG.K('textdb_text_iteration')+'&lt;/h3>'
            + "&lt;h3> "+LNG.K('textdb_msg_end_it')+"&lt;/h3>"
            + "&lt;p>"+LNG.K('textdb_msg_end_it_1')+shortestPathLength+".&lt;/p>"
            + "&lt;p>"+LNG.K('textdb_msg_end_it_2')+"&lt;/p>");
    };

    /**
     * Zeigt Texte und Buttons zum Ende des Algorithmen
     * @method
     */
    this.endAlgorithm = function() {
        //Button, der das Matching anzeigt
        toggleMatchButton = true;
        $(statusErklaerung).append("&lt;button id=show_match>"+LNG.K('algorithm_btn_match')+"&lt;/button>");
        $("#show_match").button().click(function() {
            if(toggleMatchButton){
                //alle Nicht-Matching-Kanten in den Hintergrund
                for(var e in graph.edges) graph.edges[e].setLayout("lineWidth", global_Edgelayout.lineWidth * 0.3);
                $("#show_match").button( "option", "label", LNG.K('algorithm_btn_match1') );
            }
            else{
                for(var e in graph.edges)  graph.edges[e].restoreLayout();
                $("#show_match").button( "option", "label", LNG.K('algorithm_btn_match') );
            }
            //Matching-Kanten formatieren
            for(var e in matching) setEdgeMatched(matching[e]);
            toggleMatchButton = !toggleMatchButton;
            algo.needRedraw = true;
        });
        //Forschungsaufgabe und Erklaerung
        $(statusErklaerung).append("&lt;p>&lt;/p>&lt;h3>"+LNG.K('algorithm_msg_finish')+"&lt;/h3>");
        $(statusErklaerung).append("&lt;button id=button_gotoIdee>"+LNG.K('algorithm_btn_more')+"&lt;/button>");
        $(statusErklaerung).append("&lt;h3>"+LNG.K('algorithm_msg_test')+"&lt;/h3>");
        $(statusErklaerung).append("&lt;button id=button_gotoFA1>"+LNG.K('algorithm_btn_exe1')+"&lt;/button>");
        $(statusErklaerung).append("&lt;button id=button_gotoFA2>"+LNG.K('algorithm_btn_exe2')+"&lt;/button>");
        $("#button_gotoIdee").button();
        $("#button_gotoFA1").button();
        $("#button_gotoFA2").button();
        $("#button_gotoIdee").click(function() {$("#tabs").tabs("option","active", 3);});
        $("#button_gotoFA1").click(function() {$("#tabs").tabs("option","active", 4);});
        $("#button_gotoFA2").click(function() {$("#tabs").tabs("option","active", 5);});
        // Falls wir im "Vorspulen" Modus waren, daktiviere diesen
        if(fastForwardIntervalID != null) {
            this.stopFastForward();
        }
        $("#"+st+"_button_1Schritt").button("option", "disabled", true);
        $("#"+st+"_button_vorspulen").button("option", "disabled", true);
    };

     /**
     * Ermittelt basierend den vorherigen Schritt
     * und ruft die entsprechende Funktion auf.
     * @method
     */
    this.previousStepChoice = function() {
        this.replayStep();
        if(history.length == 0){
            $("#"+st+"_button_Zurueck").button("option", "disabled", true);
        }
        $("#"+st+"_button_1Schritt").button("option", "disabled", false);
        $("#"+st+"_button_vorspulen").button("option", "disabled", false);
        this.needRedraw = true;
    };

    /**
     * Erstellt ein history-Objekt, damit Aenderungen eines Schritts rueckgaengiggemacht werden koennen.
     * @method
     */
    this.addReplayStep = function() {
        var nodeProperties = {};
        for(var key in graph.nodes) {
            nodeProperties[graph.nodes[key].getNodeID()] = {edge: JSON.stringify(graph.nodes[key].getLayout())};
        }
        var edgeProperties = {};
        for(var key in graph.edges) {
            edgeProperties[graph.edges[key].getEdgeID()] = {edge: JSON.stringify(graph.edges[key].getLayout())};
        }
        history.push({
            "previousStatusId": statusID,
            "nodeProperties": nodeProperties,
            "edgeProperties": edgeProperties,
            "matching": jQuery.extend({},matching),
            "bfsEdges": jQuery.extend({},bfsEdges),
            "shortestPathLength": shortestPathLength,
            "iteration": iteration,
            //"superNode": jQuery.extend({},superNode),
            "matched": jQuery.extend({},matched),
            "disjointPaths": jQuery.extend([],disjointPaths),
            "currentPath": currentPath,
            "htmlSidebar": $(statusErklaerung).html()
        });
        //console.log("Current History Step: ", history[history.length-1]);
    };

    /**
     * Benutzt das letzte history-Objekt, um die Aenderungen des letzten Schritts rueckgaengig zu machen.
     * @method
     */
    this.replayStep = function() {
        if(history.length > 0){
            var oldState = history.pop();
            //console.log("Replay Step", oldState);
            statusID = oldState.previousStatusId;
            matching = oldState.matching;
            bfsEdges = oldState.bfsEdges;
            shortestPathLength = oldState.shortestPathLength;
            iteration = oldState.iteration;
            //superNode = oldState.superNode;
            matched = oldState.matched;
            disjointPaths = oldState.disjointPaths;
            currentPath = oldState.currentPath;
            $("#"+st+"_div_statusErklaerung").html(oldState.htmlSidebar);
            for(var key in oldState.nodeProperties) {
                graph.nodes[key].setLayoutObject(JSON.parse(oldState.nodeProperties[key].edge));
                //graph.nodes[key].setLabel(oldState.nodeProperties[key].label);
            }
            for(var key in oldState.edgeProperties) {
                graph.edges[key].setLayoutObject(JSON.parse(oldState.edgeProperties[key].edge));
                //graph.edges[key].setAdditionalLabel(oldState.edgeProperties[key].label);
            }
        }
    };

    /**
     * Setzt das Ausgabefenster, wo Erklaerungen ausgegeben werden.
     * @param {String} fenster   Der Kontext des neuen Ausgabefensters
     * @method
     */
    this.setStatusWindow = function(fenster){
        st = fenster;
        statusErklaerung = "#"+st+"_div_statusErklaerung";
    };
    /**
     * Gibt die Laenge des kuerzesten Pfades der aktuellen Phase aus.
     * @method
     */
    this.getShortestPathLength = function(){
        return shortestPathLength;
    };
    /**
     * Gibt zurueck, ob der Knoten gematcht ist.
     * @param {Object} node Knoten
     * @method
     */
    this.isMatched = function (node){
        return (matched[node.getNodeID()] != null);
    };
    /**
     * Gibt den Partner des Knoten zurueck, falls er existiert.
     * @param {Object} node Knoten
     * @method
     */
    this.getPartner = function (node){
        return matched[node.getNodeID()];
    };
    /**
     * Gibt das aktuelle Matching zurueck.
     * @method
     */
    this.getMatching = function(){
        return matching
    };
    /**
     * Gibt den aktuellen Augmentationsweg zurueck.
     * @method
     */
    this.getPath = function () {
        return disjointPaths[currentPath];
    };
    /**
     * Beendet die aktuelle Iteration und beginnt eine neue.
     * Die Methode wird fuer die zweite Forschungsaufgabe benoetigt.
     * @method
     */
    this.startNewIteration = function() {
        this.endIteration();
        this.nextStepChoice();
    };
}

// Vererbung realisieren
HKAlgorithm.prototype = Object.create(CanvasDrawer.prototype);
HKAlgorithm.prototype.constructor = HKAlgorithm;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BipartiteGraph.html">BipartiteGraph</a></li><li><a href="BipartiteGraphDrawer.html">BipartiteGraphDrawer</a></li><li><a href="CanvasDrawer.html">CanvasDrawer</a></li><li><a href="CanvasDrawMethods.html">CanvasDrawMethods</a></li><li><a href="Edge.html">Edge</a></li><li><a href="Forschungsaufgabe1.html">Forschungsaufgabe1</a></li><li><a href="Forschungsaufgabe2.html">Forschungsaufgabe2</a></li><li><a href="Graph.html">Graph</a></li><li><a href="GraphDrawer.html">GraphDrawer</a></li><li><a href="GraphNode.html">GraphNode</a></li><li><a href="HKAlgorithm.html">HKAlgorithm</a></li></ul><h3>Global</h3><ul><li><a href="global.html#const_Colors">const_Colors</a></li><li><a href="global.html#global_Edgelayout">global_Edgelayout</a></li><li><a href="global.html#global_KnotenRadius">global_KnotenRadius</a></li><li><a href="global.html#global_NodeLayout">global_NodeLayout</a></li><li><a href="global.html#graph_constants">graph_constants</a></li><li><a href="global.html#initializeSiteLayout">initializeSiteLayout</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Sun Jun 14 2015 17:11:38 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
