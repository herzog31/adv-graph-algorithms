<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="Diese Seite demonstriert den Hopcroft-Karp-Algorithmus" />
    <meta http-equiv="X-UA-Compatible" content="IE=9">
    <meta name="author" content="Ruslan Zabrodin">
    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <script src="../library/js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="../library/js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <script src="../library/js/lang.js" type="text/javascript"></script>
    <script src="../library/js/utilities.js" type="text/javascript"></script>
    <script src="js/siteAnimation.js" type="text/javascript"></script>
    <script src="js/canvasDrawing.js" type="text/javascript"></script>
    <script src="js/graph.js" type="text/javascript"></script>
    <script src="js/algorithm.js" type="text/javascript"></script>
    <script src="js/aufgabe1.js" type="text/javascript"></script>
    <script src="js/aufgabe2.js" type="text/javascript"></script>
    <script src="js/BipartiteGraph.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            showMathMenu: false,
            showMathMenuMSIE: false
        });
    </script>
    <script type="text/javascript" src="../library/js/mathjax/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=de"></script>

    <title>Der Hopcroft-Karp-Algorithmus</title>
</head>
<body>
    <noscript>
        <div class="ui-widget">
            <div class="ui-state-error ui-corner-all" style="padding: .7em;">
                <div class="ui-icon ui-icon-alert errorIcon"></div>
                <strong>Bitte aktivieren Sie Javascript!</strong>
                <ul style="margin: 0px;">
                    <li>
                        Diese Seite benötigt Javascript, um ordnungsgemäß angezeigt zu werden.
                    </li>
                    <li>
                        In Ihrem Browser ist Javascript aktuell deaktiviert. Eine Anleitung zur Aktivierung von Javascript finden Sie beispielsweise <a href="http://www.enable-javascript.com/">hier</a>.
                    </li>
                </ul>
            </div>
        </div>
    </noscript>
    <script>
        $(document).ready(initializeSiteLayout);
        LNG.setLanguage('de');
    </script>
    <header>
        <img src="img/titel.png" alt="Matching in bipartiten Graphen: Der Hopcroft-Karp-Algorithmus">
        <!--<img src="img/hk.png" alt="Matching in bipartiten Graphen: Der Hopcroft-Karp-Algorithmus">-->
        <img style="position:absolute; right:0px" src="img/TUMLogo.png" alt="Technische Universität München">
    </header>
    <div id="tabs">
        <ul>
            <li><a href="#tab_te"><span>Einführung</span></a></li>
            <li><a href="#tab_tg"><span>Graph erstellen</span></a></li>
            <li><a href="#tab_ta"><span>Algorithmus ausführen</span></a></li>
            <li><a href="#tab_ti"><span>Beschreibung des Algorithmus</span></a></li>
            <li><a href="#tab_tf1"><span>Forschungsaufgabe 1</span></a></li>
            <li><a href="#tab_tf2"><span>Forschungsaufgabe 2</span></a></li>
            <li><a href="#tab_tw"><span>Weiteres</span></a></li>
        </ul>
        <div id="tab_te">
            <div id="te_div_Einfuehrungstext">
                <div id="te_div_beispiel1Container"><img id="te_img_beispiel1" src="img/bipartite_graph.png" alt="Bipartiter Graph"><p>Wie groß ist das maximale Matching?</p></div>
                <h1>Bipartites Matching</h1>
                <p>
                    Sei ein ungerichteter Graph G=(V,E) gegeben. Eine Teilmenge \(M \subseteq E\) heißt Matching, falls keine zwei Kanten aus M einen Knoten gemeinsam haben.
                    Ein Matching M heißt maximal, falls die Kardinalität von M maximal unter allen möglichen Matchings ist.
                    In vielen Anwendungen müssen häufig Elemente aus verschiedenen Klassen kombiniert werden.
                    Wenn nur bestimmte  Zuordnungen möglich sind, so nennt man dieses Problem <strong>Bipartites Matching</strong>.
                </p>
                <p>
                    Eine mögliche Anwendung dieses Problems ist die Zuordnung von Studenten und Arbeitsstellen.
                    Die Kanten repräsentieren mögliche Zuordnungen bzw. Qualifikationen.
                    Das Ziel ist möglicht viele passende Zuordnungen zu finden, wobei die Studenten nur eine Stelle annehmen können und die Stellen nur einmal vergeben wird.
                </p>
                <h2>Hier wird der Hopcroft-Karp-Algorithmus veranschaulicht, der das Problem der maximalen Matchings auf bipartiten Graphen löst.</h2>
                <div id ="te_div_Entscheidung">
                    <h2>Was möchtest du zuerst tun?</h2>
                    <button id="te_button_gotoDrawGraph">Den Algorithmus testen!</button> <button id="te_button_gotoIdee">Genauere Beschreibung des Algorithmus lesen</button>
                </div>
                <p></p>
            </div>
        </div>
        <div id="tab_tg">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tg_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tg_div_statusWindow" class="statusWindow">
                    <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                    <div id="tg_div_statusErklaerung">
                        <p>Um einen Knoten in einer Partition zu erstellen, mache einen Doppelklick in der Nähe dieser Partition.</p>
                        <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
                        <p>Du kannst nur Kanten zwischen verschiedenen Partitionen einfügen.</p>
                        <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
                    </div>
                    <h3>Keine Lust, selbst einen Graph zu erstellen?<br></h3>
                    <h3>Nimm ein fertiges Beispiel!<br></h3>
                    <select id="tg_select_GraphSelector" name="Wähle einen Graphen">
                        <option selected id="tg_selectoption_empty" value="empty">Selbsterstellter Graph</option>
                        <option value="random">Zufallsgraph</option>
                        <option value="standard">Standardbeispiel</option>
                        <option value="complete">Vollständiger Graph</option>
                        <option value="uneven">Ungleiche Knotenzahl</option>
                    </select>
                    <p><button id="tg_button_gotoAlgorithmTab">Fertig &ndash; weiter zum Algorithmus!</button></p>
                </div>
            </div>
            <div title="Graph erstellen" class="tabIntroDialog">
                <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                <p>Um einen Knoten in einer Partition zu erstellen, mache einen Doppelklick in der Nähe dieser Partition.</p>
                <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
                <p>Du kannst nur Kanten zwischen verschiedenen Partitionen einfügen.</p>
                <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
            </div>
        </div>
        <div id="tab_ta">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="ta_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
<!--                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>-->
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/matchingKnoten.png" alt="MatchedNode" class="LegendeIcon"></td>
                                    <td><span>Matching-Knoten</span></td>
                                </tr>
<!--                                <tr>
                                    <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Kante</span></td>
                                </tr>-->
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/matchingEdge.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Matching-Kante</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="ta_div_statusWindow" class="statusWindow">
                    <h2 class="">Status des Algorithmus</h2>
                    <div id="ta_div_abspielbuttons">
                    </div>
                    <div id="ta_div_statusTabs">
                         <ul>
                            <li><a href="#ta_div_statusErklaerung">Erklärung</a></li>
                            <li><a href="#ta_div_statusPseudocode">Pseudocode</a></li>
                        </ul>
                        <div id="ta_div_statusErklaerung">
                            <h3>Initialisierung des Algorithmus.</h3>
                            <p>Am Anfang des Algorithmus besitzt kein Knoten einen Matching-Partner. Dementsprechend ist das Matching M leer.</p>
                            <p>In jeder Iteration suchen wir eine nicht erweiterbare Menge an kürzesten knotendisjunkten Augmentationswegen.</p>
                            <p>Nicht erweiterbar bedeutet, dass es zusätzlich zu den gefundenen Pfaden keinen anderen kürzesten knotendisjunkten Augmentationsweg gibt.</p>
                            <p>Ein Augmentationsweg ist ein Weg, der mit einem ungematchten Knoten anfängt, mit einem ungematchten Knoten endet und alternierend Matching-Kanten und Nicht-Matching-Kanten benutzt.</p>
                        </div>
                        <div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                            <p class="pseudocode" id="ta_p_l1">BEGIN</p>
                            <p class="pseudocode" id="ta_p_l2">  M &larr; &empty;</p>
                            <p class="pseudocode" id="ta_p_l3">  REPEAT </p>
                            <p class="pseudocode" id="ta_p_l4">    let &Rho; = {P1,P2,...,Pk} be a maximal</p>
                            <p class="pseudocode" id="ta_p_l5">    set of vertex-disjoint shortest </p>
                            <p class="pseudocode" id="ta_p_l6">    augmenting paths with respect to M</p>
                            <p class="pseudocode" id="ta_p_l7">    M &larr; M &oplus; (P1 &cup; P2 &cup; ... &cup; Pk)</p>
                            <p class="pseudocode" id="ta_p_l8">  UNTIL &Rho; == &empty;</p>
                            <p class="pseudocode" id="ta_p_l9">RETURN M</p>
                            <p class="pseudocode" id="ta_p_l10">END</p>
                        </div>
                    </div>
                </div>
            </div>
            <div title="Algorithmus ausführen" class="tabIntroDialog">
                <h2>Den Hopcroft-Karp-Algorithmus ausführen</h2>
                <p>In diesem Schritt sehen wir, wie der Algorithmus arbeitet.</p>
                <p>Rechts vom Graph kannst du die Ausführung kontrollieren.</p>
            </div>
            <div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird der Algorithmus abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>
        <div id="tab_ti" style="display: none;">
            <div id="ti_div_Einfuehrungstext">
                <div class="BeispielbildContainer">
                    <img id="ti_img_1" src="img/path.png" alt="Suche" width="300"/><p>Augmentationsweg</p><br />
                    <img id="ti_img_2" src="img/augment.png" alt="Suche" width="350"/><p>Suche nach kürzesten Augmentationswegen</p><br />
                </div>
                <h1>Matching auf bipartiten Graphen</h1>
                <p>Gegeben ist ein bipartiter Graph G. Ein Graph ist bipartit, falls er aus zwei Knotenpartitionen U und V besteht, sodass zwischen den Knoten innerhalb der Partitionen keine Kanten existieren.
                    <!--D.h. es existieren nur Kanten, die Knoten aus der Partition V mit den Knoten aus der Partition U verbinden.-->
                    Ein Matching ist eine Menge von Kanten, sodass in dem Teilgraph, der nur die Kanten aus dem Matching enthält, alle Knoten maximal zu einer Kante inzident sind.
                    Das zu untersuchende Problem ist das Bestimmen von kardinalitätsmaximalen Matchings auf bipartiten Graphen.
                </p>
                <p> Zahlreiche Zuordnungsprobleme lassen sich als bipartites Matching-Problem modellieren.
                    Das Problem lässt sich besser veranschaulichen, wenn man sich unter Knoten der einen Partition Studenten und unter Knoten der anderen Partition Arbeitsstellen vorstellt.
                    Die Kanten repräsentieren mögliche Zuordnungen bzw. Qualifikationen.
                    Das Ziel ist möglicht viele passende Zuordnungen zu finden, wobei die Studenten nur eine Stelle annehmen können und die Stellen nur einmal vergeben wird.
                </p>
                <h1>Idee des Algorithmen</h1>
                <p>
                    Sei M das aktuelle Matching (am Anfang ist es leer). Eine Kante e aus M heißt Matching-Kante und eine Kante e nicht in M heißt freie Kante. Ein Knoten, der zu einer Matching-Kante inzident ist, heißt besetzt. Anderenfalls ist der Knoten frei.
                    Ein Augmentationsweg im Graphen G ist ein Weg, der
                    <ul>
                        <li>mit einem freien Knoten startet,</li>
                        <li>mit einem freien Knoten endet und </li>
                        <li>alternierend freie Kanten und Matching-Kanten benutzt.</li>
                    </ul>
                    Das Besondere an einem Augmentationsweg ist, dass wenn man die Matching-Kanten des Weges aus M entfernt und stattdessen die freien Kanten des Weges zu den Mathcing hinzufügt, die Kardinalität des Matchings genau um eins erhöht wird.
                    Die Eigenschaften des Augmentationswegs stellen sicher, dass die freien Kanten des Weges die Matching-Eigenschaften nicht verletzen. Ein Augmentationsweg vergrößert also das Matching.
                    Ein Theorem aus der Graphentheorie besagt, dass das Matching genau dann maximal ist, wenn es keinen Augmentationsweg gibt.
                </p>
                <p>
                    Ein einfacher Algorithmus zur Bestimmung von maximalen Matchings besteht darin, immer nach einem Augmantationsweg zu suchen und das Matching vergrößern. Existiert kein Augmentationsweg mehr, so ist das Matching optimal.
                    Allerdings kann die Laufzeit dieses Algorithmen in bestimmten Fällen lang sein. Der Algorithmus von Hopcroft und Karp verbessert die Laufzeit im Vergleich zu dem einfachen Algorithmus.
                    In jeder Iteration des Algorithmen wird eine Menge von kürzesten knotendisjunkten Augmentationswegen gesucht und das Matching mit diesen Augmentationswegen verbessert.
                    Diese Menge sollte in dem Sinne maximal sein, dass es keinen kürzesten Augmentationsweg existiert, der knotendisjunkt bezüglich der bereits gefundenen ist.
                    D.h. diese Menge muss nicht kardinalitätsmaximal sein. Nach jeder Iteration erhöht sich die Länge des kürzesten Augmentationsweges. Falls keine Augmentationwege mehr existieren, terminiert der Algorithmus.
                </p>
                <h1>Finden von kürzesten Augmentationswegen</h1>
                <p>
                    Die kürzesten Augmentationswege können mit Breiten- und Tiefensuche gefunden werden.
                    Man startet mit allen freien Knoten einer Partition und und führt die Breitensuche schrittweise von diesen Knoten aus. Dabei verteilt man die Knoten in mehreren Schichten.
                    Angefangen mit den freien Knoten einer Partition (erste Schicht) folgt man den Kanten zu allen Nachbarn dieser Knoten, die jetzt die nächte Schicht darstellen.
                    Befindet sich ein freier Knoten in dieser Schicht, so wird die Prozedur gestoppt. Andererseits erweitert man den erstellten Graphen um eine Schicht mit den Matching-Partnern der letzten Schicht.
                    Von diesen Knoten aus untersucht man wieder Nachbarknoten, wobei Knoten der vorherigen Schichten nicht betrachtet werden. Dies wiederholt man solange bis man einen freier Knoten in der aktuellen Schicht existiert oder alle Knoten untersucht wurden,
                    was bedeutet, dass es keinen weiteren Augmentationsweg existiert. Am Ende entsteht ein Schichtengraph, der alle kürzesten Augmentationswege enthält.
                </p>
                <p>
                    Um eine maximale Menge von knotendisjunkten Augmentationswegen zu finden, nimmt man den Schichtengraph aus dem letzten Schritt. Man startet mit einem freien Knoten der ersten Schicht und wendet die Tiefensuche darauf an.
                    Falls es einen Augmentationsweg gibt, der mit diesem Knoten startet, wird er gefunden. Alle Knoten, die auf diesem Weg vorkommen, werden aus dem Schichtengraphen entfernt. Wendet man diese Prozedur auf alle Knoten der
                    ersten Schicht an, so ist die gefundene Menge der kürzesten Augmentationswege knotendisjunkt und nach dem Ende dieser Prozedur existiert kein kürzester Augmentationsweg, der bzgl. der bereits gefundenen knotendisjunkt ist.
                </p>
                <h1>Was nun?</h1>
                <br style="clear: both;" />
                <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                    <h3>Einen Graph erstellen und den Algorithmus durchspielen</h3>
                    <button id="ti_button_gotoDrawGraph">Graph erstellen und daran den Algorithmus testen</button>
                    <button id="ti_button_gotoAlgorithm">Algorithmus am fertigen Beispiel ausprobieren</button>
                </div>
                <div class="Entscheidungsweg" id="ti_div_EntscheidungRight">
                    <h3>Dein Wissen an den Forschungsaufgaben testen</h3>
                    <button id="ti_button_gotoFA1">Forschungsaufgabe 1: Wie würde der Algorithmus entscheiden?</button><br>
                    <button id="ti_button_gotoFA2">Forschungsaufgabe 2: Finde die Augmentationswege</button>
                </div>
                <br style="clear: both;" />
            </div>
        </div>
        <div id="tab_tf1">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tf1_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
<!--
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Knoten</span></td>
                                </tr>
-->
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/matchingKnoten.png" alt="MatchedNode" class="LegendeIcon"></td>
                                    <td><span>Matching-Knoten</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/matchingEdge.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Matching-Kante</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tf1_div_statusWindow" class="statusWindow">
                    <h2 class="">Prüfe dein Wissen: Wie würde der Algorithmus entscheiden?</h2>
                    <div id="tf1_div_abspielbuttons">
                    </div>
                    <div id="tf1_div_statusTabs">
                         <ul>
                            <li><a href="#tf1_div_statusErklaerung">Erklärung</a></li>
                            <li><a href="#tf1_div_statusPseudocode">Pseudocode</a></li>
                        </ul>
                        <div id="tf1_div_statusErklaerung">
                            <h2>In diesem Teil kannst du dein Wissen testen: Wie würde der Algorithmus entscheiden?</h2>
                            <p>
                                Der Algorithmus wird normal ausgeführt, stoppt aber an einigen Stellen.
                                Du musst dann vorhersagen, wie der Algorithmus entscheiden würde.
                            </p>
                            <p>Tipp: Vorher nochmals die Beschreibung des Algorithmus durchlesen.</p>
                        </div>
                        <div class="PseudocodeWrapper" id="tf1_div_statusPseudocode">
                            <p class="pseudocode" id="tf_p_l1">BEGIN</p>
                            <p class="pseudocode" id="tf_p_l2">  M &larr; &empty;</p>
                            <p class="pseudocode" id="tf_p_l3">  REPEAT </p>
                            <p class="pseudocode" id="tf_p_l4">    let &Rho; = {P1,P2,...,Pk} be a maximal</p>
                            <p class="pseudocode" id="tf_p_l5">    set of vertex-disjoint shortest </p>
                            <p class="pseudocode" id="tf_p_l6">    augmenting paths with respect to M</p>
                            <p class="pseudocode" id="tf_p_l7">    M &larr; M &oplus; (P1 &cup; P2 &cup; ... &cup; Pk)</p>
                            <p class="pseudocode" id="tf_p_l8">  UNTIL &Rho; == &empty;</p>
                            <p class="pseudocode" id="tf_p_l9">RETURN M</p>
                            <p class="pseudocode" id="tf_p_l10">END</p>
                        </div>
                    </div>
                </div>
            </div>
            <div title="Forschungsaufgabe 1" class="tabIntroDialog">
                <h2>In diesem Teil kannst du dein Wissen testen: Wie würde der Algorithmus entscheiden?</h2>
                <p>
                    Der Algorithmus wird normal ausgeführt, stoppt aber an einigen Stellen. 
                    Du musst dann vorhersagen, wie der Algorithmus entscheiden würde.
                </p>
                <p>Tipp: Vorher nochmals die Beschreibung des Algorithmus durchlesen.</p>
            </div>
            <div id="tf1_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>
        <div id="tab_tf2">
            <div>
                <div class="canvasWrapper">
                    <canvas class="graphCanvas" id="tf2_canvas_graph" width="700" height="500">
                        Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                    </canvas>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/matchingKnoten.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Matching-Knoten.</span></td>
                                </tr>
                                <tr class="LegendeZeileClickable" id="tf2_tr_LegendeClickable" title="Klicke zum Ein-/Ausblenden">
                                    <td class="LegendeTabelle"><img src="img/matchingEdge.png" alt="Knoten" class="LegendeIcon"></td>
                                    <td><span>Matching-Kante.</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tf2_div_statusWindow" class="statusWindow">
                    <h2>Versuche die Augmentationswege selbst zu finden</h2>
                    <div id="tf2_div_abspielbuttons"></div>
                    <div id="tf2_div_statusErklaerung">
                        <h3>Klicke auf den Button "Nächter Schritt", um mit der Forschungsaufgabe zu beginnen.</h3>
                        <p>Klicke auf die Knoten um einen Augmentationsweg einzuzeichnen. Klicke dabei in der Reihenfolge auf die Knoten, wie sie in dem Augmentationsweg vorkommen.</p>
                        <p>Mit einem Linksklick wählst du die Knoten aus und mit einem Rechtsklich kann du deine Wahl rückgängigmachen.</p>
                    </div>
                </div>
            </div>
            <div title="Forschungsaufgabe 2" class="tabIntroDialog">
                <h2>
                    Versuche die Augmentationswege selbst zu finden.
                </h2>
                <p>Der Hopcroft-Karp-Algorithmus nutzt Augmentationswege, um ein maximales Matching zu finden.</p>
                <p>In dieser Aufgabe kannst du selbst mit Augmentationswegen experimentieren. Der Algorithmus stoppt an einigen Stellen, an denen du einen Augmentationsweg einzeichnen musst.
                    Dabei ist es nicht notwendig den kürzesten Augmentationsweg einzuzeichnen. Du kannst selber entscheiden, welchen Augmentationsweg du nutzen möchtest.</p>
            </div>
            <div id="tf2_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>
        <div id="tab_tw">
            <div id="tw_Accordion">
                <h3>Wie sieht der (Pseudo-)Code des Algorithmus aus?</h3>
                <div><pre><code>
                Eingabe: Bipartiter ungewichteter Graph G=(U &cup; V, E).
                Ausgabe: Eine Menge M &sube; E, sodass M ein Matching auf G darstellt.

                BEGIN
                   M &larr; &empty;
                      REPEAT
                        let &Rho; = {P1,P2,...,Pk} be a maximal set of
                        vertex-disjoint shortest augmenting paths with respect to M
                        M &larr; M &oplus; (P1 &cup; P2 &cup; ... &cup; Pk)
                      UNTIL &Rho; == &empty;
                   RETURN M
                END
                </code></pre></div>
                <h3>Wie schnell ist der Algorithmus?</h3>
                <div>
                    <h2>Geschwindigkeit von Algorithmen</h2>
                    <p>Die Geschwindigkeit von Algorithmen wird üblicherweise in der <strong>Anzahl an Einzelschritten</strong> gemessen, die der Algorithmus bei der Ausführung benötigt.</p>
                    <p>Einzelschritte sind beispielsweise:</p>
                    <ul>
                      <li>Zuweisungen &ndash; Weise Knoten 1 den Wert 20 zu.</li>
                      <li>Vergleiche  &ndash; Ist 20 größer als 23?</li>
                      <li>Vergleich und Zuweisung  &ndash; Falls 20 größer als 15 ist, setze Variable <var>n</var> auf 20.</li>
                      <li>Einfache Arithmetische Operationen &ndash; Was ist 5 + 5 ?</li>
                    </ul>
                    <p>Da es sehr schwierig sein kann, diese Einzelschritte exakt zu zählen, möchte man nur die ungefähre <strong>Größenordnung</strong> der Anzahl Schritte wissen.
                        Man spricht auch von der <strong>Laufzeit</strong> des Algorithmus.
                       Meistens ist es besonders interessant, zu wissen, wie die Geschwindigkeit des Algorithmus von der Größe der Eingabe (hier: Anzahl Kanten und Knoten im Graph) abhängt.</p>

                    <h2>Laufzeit des Hopcroft-Karp-Algorithmus</h2>
                    <p>
                        Angenommen der Graph enthält n Knoten und m Kanten.
                        Da in jeder Iteration des Algorithmen eine maximale knotendisjunkte Menge von kürzesten Augmentationswegen gefunden wird, erzwingt dies,
                        dass die Länge des kürzesten Augmentationsweges nach jeder Iteration um mindestens eins erhöht wird.
                        <!--Sei M ein Matching und M* das optimale Matching. Dann existieren |M*|-|M| knotendisjunkte Augmentationswege bzgl. M.-->
                        Sei M ein Matching und l die Länge des kürzesten Augmentationsweges bzgl. M. Dann ist die Kardinalität des optimalen Matchings maximal |M| + n/(l+1).
                        Nach der &radic;<span style="text-decoration:overline;">&nbsp;n&nbsp;</span> Iteration beträgt die Länge des kürzesten Augmentationsweges mindestens &radic;<span style="text-decoration:overline;">&nbsp;n&nbsp;</span>.
                        Dann existieren maximal n/&radic;<span style="text-decoration:overline;">&nbsp;n&nbsp;</span> = &radic;<span style="text-decoration:overline;">&nbsp;n&nbsp;</span> zusätzliche Augmentationen.
                        Daraus geht hervor, dass es maximal 2*&radic;<span style="text-decoration:overline;">&nbsp;n&nbsp;</span> Iterationen geben kann.
                    </p>
                    <p> Jede Iteration kann in  O(m) Schritten durchgeführt werden. Dazu wird einmal Breitensuche und einmal Tiefensuche ausgeführt. Ausserdem wird das
                        Matching aktualisiert. Jede dieser Operationen benötigt maximal O(m) Schritte, da jede Kante maximal
                        zweimal betrachtet wird (von beiden inzidenten Knoten aus). Dann ist die Laufzeit des
                        Algorithmen
                        O(m&radic;<span style="text-decoration:overline;">&nbsp;n&nbsp;</span>).
                        Den vollständigen Beweis kann der interessierte Leser in der geeigneten Literatur nachlesen.
                    </p>
                </div>
                <h3>Wie beweist man, dass der Algorithmus stets ein korrekt arbeitet?</h3>
                <div>
                    <!--<h2>Ein mathematischer Beweis</h2>-->
                    <p>
                        In jeder Iteration des Algorithmen wird nach Augmentationswegen gesucht und das Matching wird verbessert. Es können nur endlich viele Verbesserungen durchgeführt werden, sodass der
                        Algorithmus terminiert.
                        Nach der letzten Iteration des Algorithmen existieren keine Augmentationswege mehr. Dann ist das Matching optimal und der Hopcroft-Karp-Algorithmus berechnet das richtige Ergebnis.
                    </p>
                </div>
                <h3>Wo finde ich noch mehr Informationen zu Graphalgorithmen?</h3>
                <div><p>Weitere Graphalgorithmen werden auf der <a href="http://www-m9.ma.tum.de/Allgemeines/Routenplanung">Webseite des Lehrstuhls M9</a> der TU München erklärt.</p>
                <p>Ein <a href="http://www.ma.tum.de/Studium/Studieninteressierte">Mathematikstudium an der TU München</a> beantwortet alle Fragen zur Graphentheorie (falls eine Lösung bekannt ist).</p>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <p class="Disclaimer">
            IDP Projekt von Ruslan Zabrodin am Lehrstuhl M9 der Technischen Universität München. 2015 | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Disclaimer und Rechtshinweise</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">Impressum</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Anregungen</a>
        </p>
    </footer>
</body>