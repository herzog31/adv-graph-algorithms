{ 
  "name": "de",
  "fields" : {
    "algorithm_btn_prev": "Zurück",
    "algorithm_btn_next": "Nächster Schritt",
    "algorithm_btn_frwd": "Vorspulen",
    "algorithm_btn_paus": "Pause",
    "algorithm_msg_finish": "Was nun?",
    "algorithm_msg_test": "Forschungsaufgaben ausprobieren:",
    "algorithm_btn_more": "Beschreibung des Algorithmus lesen",
    "algorithm_btn_exe1": "Wie würde der Algorithmus entscheiden?",
    "algorithm_btn_exe2": "Welche Sortierung der Kanten ist optimal?",
    "algorithm_status1": "Kosten des Anfangsknotens: ",
    "algorithm_status2": "Kosten der Kante: ",
    "algorithm_status3": "Kosten des Zielknotens: ",
    "algorithm_status4": "Die Kosten des Zielknotens müssen aktualisiert werden.",
    "algorithm_status5": "Die Kosten des Zielknotens können nicht aktualisiert werden.",
    "textdb_text_oneedge": "eine Kante",
    "textdb_text_edges": "Kanten",
    "textdb_text_phase": "Phase",
    "textdb_text_of": "von",

    "textdb_msg_init": "Initialisierung",
    "textdb_msg_init_1": "Am Anfang des Algorithmus besitzen alle Knoten keinen Matching-Partner. Die Menge des Kanten in Matchin M ist dementsprechend leer.",
    "textdb_msg_init_2": "In jedem Schritt des Algorithmus suchen wir eine maximale Menge an kürzesten knotendisjunkten verbessernden Pfaden.",
    "textdb_msg_init_3": "Maximal heißt hier, dass es zusätzlich zu den gefundenen Pfaden keinen anderen kürzesten knotendisjunkten verbessernden Pfad gibt.",

    "textdb_msg_begin_it": "Nächste Iteration",
    "textdb_msg_end_it": "Iteration Ende",
    "textdb_msg_end_it_1": "Es gibt keinen knotendisjunkten kürzensten verbessernden Pfad bezüglich der bereits gefundenen.",

    "textdb_msg_end_algo": "Algorothmus Ende",
    "textdb_msg_end_algo_1": "Es gibt keinen verbessernden Pfad mehr. Das Matching ist optimal.",

    "textdb_msg_path": "Finde einen kürzesten augmentierenden Pfad",
    "textdb_msg_path_1a": "Zuerst wird mittels der Breitensuche ein gerichteter Graph aufgebaut, der alle kürzesten verbessernden Pfade enthält.",
    "textdb_msg_path_1b": "Die Suche startet mit allen freien Knoten auf der linken Seite.",
    "textdb_msg_path_1c": "Es werden nur Kanten verfolgt, die nicht zum Matching gehören, da diese Knoten frei sind.",

    "textdb_msg_path_shortest": "Die Länge des kürzesten verbessernden Pfades beträgt: ",

    "textdb_msg_path_highlight": "Verbessernde Pfad",

    "textdb_msg_update": "Aktualisiere das Matching",
    "textdb_msg_update_1": "Die alternierenden Kanten des gefundenen verbessernden Pfades werden vertauscht.",
    "textdb_msg_update_2": "Die Kardinalität des Matching wird um eins erhöht.",

    "textdb_msg_case2_6": "Prüfe, ob die rote Kante Teil eines negativen Kreises ist.",
    "textdb_msg_case2_7": "Dafür wird getestet, ob die bisher bekannten Kosten des Zielknotens höher sind als die Kosten des Anfangsknotens plus der Kosten der Kante.",
    "textdb_msg_case2_8": "Falls dies der Fall ist, so ist die rote Kante Teil eines negativen Kreises.",

    "textdb_msg_case3_1": "Ergebnis: Negativer Kreis gefunden",
    "textdb_msg_case3_2": "Der Graph enthält einen erreichbaren negativen Kreis.",
    "textdb_msg_case3_3": "Von der Kante, die auf den negativen Kreis hingewiesen hat, sind wir über die Vorgängerkanten so lange zurückgegangen, bis wir  im Kreis gelaufen sind. Dieser negative Kreis wurde im Graphen hellrot markiert.",
    "textdb_msg_case4_1": "Ergebnis: Algorithmus erfolgreich beendet",
    "textdb_msg_case4_2": "In diesem Graph existiert kein erreichbarer negativer Kreis, und alle Kosten wurden korrekt berechnet.",
    "textdb_msg_case4_3": "Bewege den Mauszeiger auf einen Knoten, um den günstigsten Weg vom Startknoten aus zu sehen.",
    "textdb_msg_case5_1": "Jetzt kann der Algorithmus beginnen!",
    "aufgabe1_btn_next_question": "Zur nächsten Frage vorspulen",
    "aufgabe1_btn_retry": "Nochmal versuchen",
    "aufgabe1_btn_exe2": "Probiere die zweite Forschungaufgabe:",
    "aufgabe1_question1": "Welchen Abstandswert wird der Algorithmus für den roten Knoten eintragen?",
    "aufgabe1_answer1": "Unendlich",
    "aufgabe1_answer1_reason": "Da der Algorithmus noch keine Berechnungen durchgeführt hat, haben alle Knoten den Abstand unendlich zum Startknoten.",
    "aufgabe1_answer2_reason1": "Der Wert des Knotens wurde aktualisiert, weil über die rote Kante eine Abkürzung möglich war.",
    "aufgabe1_answer2_reason2": "Es ist",
    "aufgabe1_answer2_reason3": "Der Wert des Knotens wurde nicht verändert, weil keine Abkürzung über die rote Kante möglich war.",
    "aufgabe1_question3": "Weist die rote Kante auf einen erreichbaren negativen Kreis hin?",
    "aufgabe1_answer3_reason1": "Die Kante ist \"inkonsistent\", es ist immernoch einer Abkürzung über diese Kante möglich.",
    "aufgabe1_answer3_reason2": "Beweis:",
    "aufgabe1_answer3_reason3": "Die Kante ist \"konsistent\", es ist keine Abkürzung über diese Kante möglich.",
    "aufgabe1_msg_case3_4": "Der Kreis ist in hellrot im Graph markiert.",
    "aufgabe1_text_yes": "Ja",
    "aufgabe1_text_no": "Nein",
    "aufgabe1_text_infinity": "Unendlich",
    "aufgabe1_text_question": "Frage",
    "aufgabe1_text_results": "Ergebnisse",
    "aufgabe1_text_right_answer": "Richtige Antwort:",
    "aufgabe1_result1": "Herzlichen Glückwunsch!",
    "aufgabe1_result2": "Du hast alle Fragen korrekt beantwortet.",
    "aufgabe1_result3": "Forschungsaufgabe beendet",
    "aufgabe1_result4": "Anzahl Fragen:",
    "aufgabe1_result5": "Richtig beantwortet:",
    "aufgabe1_result6": "Falsch beantwortet:",
    "aufgabe2_btn_rev": "Letzte Auswahl rückgängig machen",
    "aufgabe2_btn_more": "Weitere Informationen über den Algorithmus",
    "aufgabe2_msg_1": "Der Algorithmus hat nun die Abstandswerte aller Knoten initialisiert.",
    "aufgabe2_msg_2": "Klicke auf die Kante, die der Algorithmus als Erstes überprüfen soll.",
    "aufgabe2_msg_3": "Update der Kanten",
    "aufgabe2_msg_4": "Der Algorithmus hat nun geprüft, ob über die gewählte Kante eine Abkürzung möglich ist, und die Abstandswerte aktualisiert.",
    "aufgabe2_msg_5": "Klicke auf die Kante, die als nächstes überprüft werden soll.",
    "aufgabe2_result_1": "Da keine Kanten existieren ist die gewählte Kantenreihenfolge optimal.",
    "aufgabe2_result_2": "Die gewählte Kantenreihenfolge ist optimal, der Bellman-Ford-Algorithmus würde nach nur einer Phase bereits ein korrektes Ergebnis haben.",
    "aufgabe2_result_3": "Ergebnis",
    "aufgabe2_result_4_a": "Der Graph enthält einen erreichbaren negativen Kreis. Da dies erst am Ende erkannt werden kann, hätte der Algorithmus alle",
    "aufgabe2_result_4_b": "Phasen",
    "aufgabe2_result_4_c": "benötigt. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_result_5_a": "Mit dieser Reihenfolge würde der Algorithmus nach",
    "aufgabe2_result_5_b": "ein korrektes Ergebnis haben. Es ist beispielsweise noch eine Abkürzung über die rote Kante möglich.",
    "aufgabe2_explan1": "Welche Reihenfolgen sind optimal?",
    "aufgabe2_explan2": "Leider ist es aufwendig, die optimale Reihenfolge zu finden. Es ist genauso schwierig (also langwierig), wie der Algorithmus selbst.",
    "aufgabe2_explan3": "Wofür braucht man eine gute Sortierung?",
    "aufgabe2_explan4": "In der Praxis ist es sinnvoll, den Algorithmus abzubrechen, sobald die letzte Phase keine Veränderung mehr brachte, denn dann ist das Ergebnis optimal.",
    "aufgabe2_explan5": "Es existieren heuristische Verfahren (Näherungsverfahen), die eine möglichst gute Sortierung zu ermitteln versuchen."
  }
}
