<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="Diese Seite demonstriert den Bellman-Ford-Algorithmus für kürzeste Wege in Graphen." />
    <meta http-equiv="X-UA-Compatible" content="IE=9">
    <meta name="author" content="Mark J. Becker, Aleksejs Voroncovs">
    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
    <link rel="stylesheet" type="text/css" href="../library/css/style.css" />
    <script src="../library/js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="../library/js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <script src="../library/js/lang.js" type="text/javascript"></script>
    <script src="js/utilities.js" type="text/javascript"></script>
    <script src="js/siteAnimation.js" type="text/javascript"></script>
    <script src="js/canvasDrawing.js" type="text/javascript"></script>
    <script src="js/graph.js" type="text/javascript"></script>
    <script src="js/algorithm.js" type="text/javascript"></script>
    <script src="js/textDB.js" type="text/javascript"></script>
    <script src="js/BipartiteGraph.js" type="text/javascript"></script>
    <script src="js/aufgabe1.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            showMathMenu: false,
            showMathMenuMSIE: false
        });
    </script>
    <script type="text/javascript" src="../library/js/mathjax/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=de"></script>

    <title>Die Ungarische Methode</title>
</head>
<body>
<noscript>
    <div class="ui-widget">
        <div class="ui-state-error ui-corner-all" style="padding: .7em;">
            <div class="ui-icon ui-icon-alert errorIcon"></div>
            <strong>Bitte aktivieren Sie Javascript!</strong>
            <ul style="margin: 0px;">
                <li>
                    Diese Seite benötigt Javascript, um ordnungsgemäß angezeigt zu werden.
                </li>
                <li>
                    In Ihrem Browser ist Javascript aktuell deaktiviert. Eine Anleitung zur Aktivierung von Javascript finden Sie beispielsweise <a href="http://www.enable-javascript.com/">hier</a>.
                </li>
            </ul>
        </div>
    </div>
</noscript>
<script>
    LNG.setLanguage('de');
    $(function() {
        initializeSiteLayout();
        $("#year").html(new Date().getFullYear());
    });
</script>
<header>
    <img src="img/titel.png" alt="Ungarische Methode">
    <img style="position:absolute; right:0px" src="img/TUMLogo.png" alt="Technische Universität München">
</header>
<div id="tabs">
    <ul>
        <li><a href="#tab_te"><span>Einführung</span></a></li>
        <li><a href="#tab_tg"><span>Graph erstellen</span></a></li>
        <li><a href="#tab_ta"><span>Algorithmus ausführen</span></a></li>
        <li><a href="#tab_ti"><span>Beschreibung des Algorithmus</span></a></li>
        <li><a href="#tab_tf1"><span>Forschungsaufgabe 1</span></a></li>
        <li><a href="#tab_tf2"><span>Forschungsaufgabe 2</span></a></li>
        <li><a href="#tab_tw"><span>Weiteres</span></a></li>
    </ul>
    <div id="tab_te">
        <div id="te_div_Einfuehrungstext">
            <div id="te_div_beispiel1Container"><img id="te_img_beispiel1" src="img/beispiel1.png" alt="Bipartiter Graph mit Kantengewichten"><p>Wie sieht das optimale Matching aus?</p></div>
            <h1>Matchings optimalen Gewichts</h1>
            <p>Das Finden von Kombinationen bzw. Matchings von Elementen unterschiedlicher Klassen ist ein häufig auftretendes Problem. Meistens reicht es jedoch nicht aus, einfach nur ein Matching zu finden, sondern man möchte das Matching mit dem höchsten Nutzen oder den niedrigsten Kosten finden.</p>
            <p>Als Beispiel ist hierfür die Arbeit einer Jobvermittlung zu nennen. Diese muss Arbeitssuchende anhand ihrer Eignung optimal auf die verfügbaren Arbeitsplätze verteilen. Dieses Problem lässt sich als bipartiter Graph darstellen.</p>
            <h2>Die hier vorgestellte Ungarische Methode findet dann optimale Matchings in bipartiten Graphen.</h2>
            <div id ="te_div_Entscheidung">
                <h2>Was möchtest du zuerst tun?</h2>
                <button id="te_button_gotoDrawGraph">Den Algorithmus testen!</button>
                <button id="te_button_gotoIdee">Genauere Beschreibung des Algorithmus lesen</button>
            </div>
            <p></p>
            <br style="clear: both;" />
        </div>
    </div>
    <div id="tab_tg">
        <div>
            <div class="canvasWrapper">
                <canvas class="graphCanvas" id="tg_canvas_graph" width="700" height="500">
                    Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                </canvas>
                <div class="Legende" id="tg_div_Legende">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    <div class="LegendeText">
                        <table>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Knoten</span></td>
                            </tr>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Kante</span></td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="LegendeMinimized">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                </div>
            </div>
            <div id="tg_div_statusWindow" class="statusWindow">
                <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                <div id="tg_div_statusErklaerung">
                    <p>Um einen Knoten in einer Partition zu erstellen, mache einen Doppelklick in der Nähe dieser Partition.</p>
                    <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
                    <p>Du kannst nur Kanten zwischen verschiedenen Partitionen einfügen.</p>
                    <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
                </div>
                <h3>Keine Lust, selbst einen Graph zu erstellen?<br></h3>
                <h3>Nimm ein fertiges Beispiel!<br></h3>
                <select id="tg_select_GraphSelector" name="Wähle einen Graphen">
                    <option selected id="tg_selectoption_empty">Selbsterstellter Graph</option>
                    <option>Zufallsgraph</option>
                    <option>Standardbeispiel</option>
                </select>
                <p><button id="tg_button_gotoAlgorithmTab">Fertig &ndash; weiter zum Algorithmus!</button></p>
            </div>
        </div>
        <div title="Graph erstellen" class="tabIntroDialog">
            <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
            <p>Um einen Knoten in einer Partition zu erstellen, mache einen Doppelklick in der Nähe dieser Partition.</p>
            <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
            <p>Du kannst nur Kanten zwischen verschiedenen Partitionen einfügen.</p>
            <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
        </div>
    </div>
    <div id="tab_ta">
        <div>
            <div class="canvasWrapper">
                <canvas class="graphCanvas" id="ta_canvas_graph" width="700" height="500">
                    Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                </canvas>
                <div class="Legende">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    <div class="LegendeText">
                        <table>
                            <!--                                <tr>
                                                                <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                                                <td><span>Knoten</span></td>
                                                            </tr>-->
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingKnoten.png" alt="MatchedNode" class="LegendeIcon"></td>
                                <td><span>Matching-Knoten</span></td>
                            </tr>
                            <!--                                <tr>
                                                                <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                                                <td><span>Kante</span></td>
                                                            </tr>-->
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingEdge.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Matching-Kante</span></td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="LegendeMinimized">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                </div>
            </div>
            <div id="ta_div_statusWindow" class="statusWindow">
                <h2 class="">Status des Algorithmus</h2>
                <div id="ta_div_abspielbuttons">
                </div>
                <div id="ta_div_statusTabs">
                    <ul>
                        <li><a href="#ta_div_statusErklaerung">Erklärung</a></li>
                        <li><a href="#ta_div_statusPseudocode">Pseudocode</a></li>
                    </ul>
                    <div id="ta_div_statusErklaerung">
                        <h3>Die Ungarische Methode</h3>
                        <p>Klicke auf <strong>Nächster Schritt</strong>, um den Algorithmus zu starten.</p>
                    </div>
                    <div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                        <p class="pseudocode" id="ta_p_l1">BEGIN</p>
                        <p class="pseudocode" id="ta_p_l2">  initialize labels</p>
                        <p class="pseudocode" id="ta_p_l3">  WHILE matching is not complete DO</p>
                        <p class="pseudocode" id="ta_p_l4">    find a root of an alternating path</p>
                        <p class="pseudocode" id="ta_p_l5">    WHILE alternating path not found DO</p>
                        <p class="pseudocode" id="ta_p_l6">      try to find alternating path</p>
                        <p class="pseudocode" id="ta_p_l7">      in equality graph</p>
                        <p class="pseudocode" id="ta_p_l8">      IF alt. path not found</p>
                        <p class="pseudocode" id="ta_p_l9">      THEN update labels</p>
                        <p class="pseudocode" id="ta_p_l10">    END</p>
                        <p class="pseudocode" id="ta_p_l11">    increase matching</p>
                        <p class="pseudocode" id="ta_p_l12">  END</p>
                        <p class="pseudocode" id="ta_p_l13">END</p>
                        <h3>Status der Variablen:</h3>
                        <table class="algoInformationen">
                            <tr>
                                <th class="algoInfoTH"><span>Matching</span></th>
                                <th class="algoInfoTH"><span>S</span></th>
                                <th class="algoInfoTH"><span>T</span></th>
                            </tr>
                            <tr>
                                <td id="ta_td_matching" class="algoInfoTD">&#8709;</td>
                                <td id="ta_td_setS" class="algoInfoTD">&#8709;</td>
                                <td id="ta_td_setT" class="algoInfoTD">&#8709;</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div title="Algorithmus ausführen" class="tabIntroDialog">
            <h2>Die Ungarische Methode ausführen</h2>
            <p>In diesem Schritt sehen wir, wie der Algorithmus arbeitet.</p>
            <p>Rechts vom Graph kannst du die Ausführung kontrollieren.</p>
        </div>
        <div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
            <h2>Beim Wechsel des Tabs wird der Algorithmus abgebrochen.</h2>
            <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
        </div>
    </div>
    <div id="tab_ti">
        <div id="ti_div_Einfuehrungstext">
            <div class="BeispielbildContainer">
                <img id="ti_img_beispiel1" src="img/beispiel_optimal.png" alt="Optimales Matching" /><p>Bild 1: Ein optimales Matching (grün)</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_markierungen.png" alt="Markierungen" /><p>Bild 2: Knotenmarkierungen</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_gleichheitsgraph.png" alt="Gleichheitsgraph" /><p>Bild 3: Gleichheitsgraph</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_frei.png" alt="Matched / Frei" /><p>Bild 4: Freie (a,f) und Matched Knoten (b,c,d,e)</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_alternierend.png" alt="Alternierender Pfad" /><p>Bild 5: Ein alternierender Pfad (f,e,d)</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_augment.png" alt="Augmentierender Pfad" /><p>Bild 6: Ein augmentierender Pfad (f,e,d,c,b,a)</p>
            </div>
            <h1>Das Finden von optimalen Matchings</h1>

            <p>Im Alltag kann man viele Zuordnungsprobleme finden, die mittels Matchings auf bipartiten Graphen modelliert werden könnnen. Hier möchten wir uns speziell mit gewichteten Zuordnungsproblemen beschäftigen.</p>
            <p>Als Beispiel betrachten wir folgende Problemstellung: Ein Unternehmer hat in seinem Betrieb eine Menge von Aufgaben, die bearbeitet werden müssen. Seine Mitarbeiter sind aufgrund verschiedener Qualifikationen aber nicht alle gleichermaßen für jede Aufgabe geeignet. Das bedeutet, dass jeder Mitarbeiter eine andere Anzahl von Stunden zur Bearbeitung einer Aufgabe benötigt. Weil der Unternehmer effizient wirtschaften möchte, muss er die Aufgaben so verteilen, dass die Gesamtanzahl der Arbeitsstunden möglichst gering ist.</p>
            <p>Wir können dieses Problem als bipartiten Graphen mit Knotenmengen \(X\) für die Mitarbeiter und \(Y\) für die Aufgaben darstellen. Die gewichteten Kanten zwischen den Mengen definieren dann die Anzahl der Stunden, die ein Mitarbeiter \(x\) für Aufgabe \(y\) benötigt. Jetzt gilt es ein perfektes Matching zu finden, bei dem die Summe aller Kantengewichte minimal ist.</p>
            <p>&nbsp;</p>
            
            <h1>Die Ungarische Methode</h1>
            <p>Das Problem kann mittels der Ungarischen Methode gelöst werden, die 1955 von Harold W. Kuhn auf Grundlage der Ideen zweier ungarische Mathematiker entwickelt wurde. Der Algorithmus wurde später von James Munkres verbessert und basiert auf einem zentralen Theorem für dessen Verständnis wir aber ein paar Begriffe benötigen:</p>

            <p><strong>Markierung</strong><br />
            Wir führen eine einfache Hilfsfunktion oder Markierung \(l\) ein, die jedem Knoten im Graph eine reelle Zahl so zuordnet, dass die Summe der Markierungen zweier Knoten mindestens so groß ist, wie das Kantengewicht \(w\) der Kante, die diese Knoten verbindet (vgl. Bild 2).</p>
            <p style="text-align: center;">\(l(x) + l(y) \ge w(x, y)\)</p>

            <p><strong>Gleichheitsgraph</strong><br />
            Mittels der Markierungen können wir einen Gleichheitsgraph \(G_l = (V, E_l)\) definieren der alle Knoten aus unserem Ausgangsgraph besitzt. Die Kantenmenge enthält jedoch nur die Kanten, deren Gewicht genau der Summe der Markierungen ihrer Knoten entspricht (vgl. Bild 3).</p>
            <p style="text-align: center;">\(E_l = \{(x,y) \in E\ |\ l(x) + l(y) = w(x, y)\}\)</p>

            <p>Nun zu dem oben angesprochenem Theorem. Das Kuhn-Munkres-Theorem besagt, dass wenn man ein perfektes Matching im Gleichheitsgraph findet, dieses im Ausgangsgraph maximal ist. Das Problem des optimalen Matchings kann man damit also auf das Finden eines perfekten Matchings im Gleichheitsgraph reduzieren.</p>

            <p>Bevor wir nun zum eigentlichen Algorithmus kommen, hier noch ein paar Hinweise:</p>

            <p>Die Ungarische Methode in der hier beschriebenen Form findet maximale Matchings, also Matchings mit möglichst hohen Kantengewichten. Das bedeutet, dass wir das zu Beginn geschilderte Problem umformen müssen. Dazu kann man die Kantengewichte durch einen Vorzeichenwechsel "spiegeln", d.h. aus \(w(x,y)\) macht man \(-w(x,y)\).</p>

            <p>Außerdem muss der bipartite Graph, auf den wir den Algorithmus anwenden vollständig sein. Das heißt, es muss gleich viele Knoten in \(X\) und \(Y\) geben und von jedem Knoten einer Partition müssen Kanten zu jedem Knoten der anderen Partition führen. In unserem Beispiel wäre dies nicht der Fall, wenn ein Mitarbeiter eine Aufgabe gar nicht bearbeiten kann. In diesem Fall fügt man neutrale Knoten und Kanten mit Kantengewicht \(0\) ein, sodass der Graph vollständig wird. Sofern die hinzugefügten neutralen Elemente nach Ausführung des Algorithmus im gefundenen Matching enthalten sind, kann man sie einfach wieder entfernen.</p>
            <p>&nbsp;</p>

            <h1>Der Ablauf des Algorithmus</h1>

            <p>Das Finden eines perfekten Matchings im Gleichheitsgraph geschieht schrittweise. Der Algorithmus beginnt mit einem leeren Matching und versucht dieses in jedem Schritt zu verbessern, bis es perfekt ist.</p>

            <p>Zu Beginn bestimmt der Algorithmus für alle Knoten eine Markierung. Die Markierung eines Knoten aus \(X\) entspricht dem Gewicht seiner größten Kante und \(0\) für einen Knoten aus \(Y\). Mittels der Markierungen bestimmt der Algorithmus dann einen Gleichheitsgraph. Für den weiteren Ablauf definieren wir zunächst weitere Begriffe:</p>

            <p><strong>Alternierende und augmentierende Pfade</strong><br />
            Wir sagen, ein Knoten wurde gematcht, wenn er eine Kante besitzt, die im aktuellen Matching enthalten ist. Ansonsten nennen wir ihn frei (vgl. Bild 4).<br />
            Ein alternierender Pfad ist eine Abfolge von Kanten, bei dem die Kanten abwechselnd im Matching \(M\) enthalten und nicht enthalten \(E \setminus M\) sind (vgl. Bild 5).<br />Ein alternierender Pfad ist zusätzlich augmentierend, wenn Anfangs- und Endknoten beide frei sind (vgl. Bild 6).</p>

            <p>Um das bestehende noch leere Matching zu verbessern, sucht sich der Algorithmus einen Knoten aus \(X\), der noch keinen Matchingpartner besitzt. Ausgehend von diesem, versucht der Algorithmus einen augmentierenden Pfad zu finden. Dazu baut der Algorithmus schrittweise einen alternierenden Pfad, solange bis dieser augmentierend wird oder es keine weitere Kante mehr gibt. Die dabei besuchten Knoten teilen wir in die Mengen \(S\) für besuchte Knoten aus \(X\) und die Menge \(T\) für besuchte Knoten aus \(Y\) ein.</p>

            <p>Es lässt sich nicht immer ein augmentierender Pfad finden. Dann muss der Algorithmus die Markierungen verbessern, indem er zunächst ein \(\Delta\) bestimmt. Der Algorithmus betrachtet alle Paare aus besuchten Knoten \(s \in S\) und unbesuchten Knoten \(y \in Y \setminus T\) und bildet das Minimum aus der Summe ihrer Markierungen abzüglich des Gewichts der Kante zwischen beiden Knoten.</p>

            <p style="text-align: center;">\(\Delta = \min\limits_{s \in S\ \wedge\ y \in Y \setminus T}\{l(s) + l(y) - w(s,y)\}\)</p>

            <p>Mittels \(\Delta\) kann man nun die Markierungen aller Knoten anpassen. Danach bestimmt der Algorithmus einen neuen Gleichheitsgraph und sucht erneut nach einem augmentierenden Pfad.</p>

            <p style="text-align: center;">
            \(\begin{equation}
               l^\prime(v) =
               \begin{cases}
                 l(v) - \Delta & v \in S\\
                 l(v) + \Delta & v \in T \\
                 l(v) & sonst
               \end{cases}
            \end{equation}\)
            </p>

            <p>Wenn der Algorithmus einen augmentierenden Pfad findet, verbessert er das Matching, indem er die Kanten des Pfades, die nicht in dem Matching enthalten sind, dem Matching hinzufügt und die Kanten des Pfades, die im Matching enthalten sind, entfernt. Dieses Vorgehen wird wiederholt, bis jeder Knoten einen Matchingpartner hat und das Matching so perfekt ist. Nach dem o.g. Theorem ist das bestimmte Matching dann bezüglich der Kantengewichte ein maximales Matching.</p>
            <p>&nbsp;</p>

            <h1>Was nun?</h1>
            <br style="clear: both;" />
            <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                <h3>Einen Graph erstellen und den Algorithmus durchspielen</h3>
                <button id="ti_button_gotoDrawGraph">Graph erstellen und daran den Algorithmus testen</button>
                <button id="ti_button_gotoAlgorithm">Algorithmus am fertigen Beispiel ausprobieren</button>
            </div>
            <div class="Entscheidungsweg" id="ti_div_EntscheidungRight">
                <h3>Sein Wissen an den Forschungsaufgaben testen</h3>
                <button id="ti_button_gotoFA1">Forschungsaufgabe: Wie würde der Algorithmus entscheiden?</button>
                <button id="ti_button_gotoFA2">Forschungsaufgabe: TODO</button>
            </div>
            <br style="clear: both;" />
        </div>
    </div>
    <div id="tab_tf1">
        <div>
            <div class="canvasWrapper">
                <canvas class="graphCanvas" id="tf1_canvas_graph" width="700" height="500">
                    Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                </canvas>
                <div class="Legende">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    <div class="LegendeText">
                        <table>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingKnoten.png" alt="MatchedNode" class="LegendeIcon"></td>
                                <td><span>Matching-Knoten</span></td>
                            </tr>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingEdge.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Matching-Kante</span></td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="LegendeMinimized">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                </div>
            </div>
            <div id="tf1_div_statusWindow" class="statusWindow">
                <h2 class="">Prüfe dein Wissen: Wie würde der Algorithmus entscheiden?</h2>
                <div id="tf1_div_abspielbuttons">
                </div>
                <div id="tf1_div_questionModal" class="ui-widget ui-widget-content ui-corner-all" style="display: none;">
                </div>
                <div id="tf1_div_statusTabs">
                    <ul>
                        <li><a href="#tf1_div_statusErklaerung">Erklärung</a></li>
                        <li><a href="#tf1_div_statusPseudocode">Pseudocode</a></li>
                    </ul>
                    <div id="tf1_div_statusErklaerung">
                        <h3>Die Ungarische Methode</h3>
                        <p>Bei dieser Aufgabe kannst du zeigen, wie gut du den Algorithmus verstanden hast. Erstelle dir einen beliebigen Graphen und starte den Algorithmus. An manchen Stellen wird der Algorithmus stoppen und dann bist du gefragt.</p>
                        <p>Du wirst verschiedene Fragen zum Ablauf des Algorithmus bekommen. Am Ende bekommst du dann eine Auswertung, die dir zeigt, wie gut du abgeschnitten hast.</p>
                        <p>Klicke auf <strong>Nächster Schritt</strong> um den Algorithmus zu starten. Viel Erfolg!</p>
                    </div>
                    <div class="PseudocodeWrapper" id="tf1_div_statusPseudocode">
                        <p class="pseudocode" id="tf1_p_l1">BEGIN</p>
                        <p class="pseudocode" id="tf1_p_l2">  initialize labels</p>
                        <p class="pseudocode" id="tf1_p_l3">  WHILE matching is not complete DO</p>
                        <p class="pseudocode" id="tf1_p_l4">    find a root of an alternating path</p>
                        <p class="pseudocode" id="tf1_p_l5">    WHILE alternating path not found DO</p>
                        <p class="pseudocode" id="tf1_p_l6">      try to find alternating path</p>
                        <p class="pseudocode" id="tf1_p_l7">      in equality graph</p>
                        <p class="pseudocode" id="tf1_p_l8">      IF alt. path not found</p>
                        <p class="pseudocode" id="tf1_p_l9">      THEN update labels</p>
                        <p class="pseudocode" id="tf1_p_l10">    END</p>
                        <p class="pseudocode" id="tf1_p_l11">    increase matching</p>
                        <p class="pseudocode" id="tf1_p_l12">  END</p>
                        <p class="pseudocode" id="tf1_p_l13">END</p>
                        <h3>Status der Variablen:</h3>
                        <table class="algoInformationen">
                            <tr>
                                <th class="algoInfoTH"><span>Matching</span></th>
                                <th class="algoInfoTH"><span>S</span></th>
                                <th class="algoInfoTH"><span>T</span></th>
                            </tr>
                            <tr>
                                <td id="tf1_td_matching" class="algoInfoTD">&#8709;</td>
                                <td id="tf1_td_setS" class="algoInfoTD">&#8709;</td>
                                <td id="tf1_td_setT" class="algoInfoTD">&#8709;</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div id="tf1_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
            <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
            <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex="-1">in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
        </div>
    </div>
    <div id="tab_tf2">
        <div>
            <div class="canvasWrapper">
                <canvas class="graphCanvas" id="tf2_canvas_graph" width="700" height="500">
                    Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                </canvas>
                <div class="Legende">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    <div class="LegendeText">
                        <table>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingKnoten.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Matching-Knoten.</span></td>
                            </tr>
                            <tr class="LegendeZeileClickable" id="tf2_tr_LegendeClickable" title="Klicke zum Ein-/Ausblenden">
                                <td class="LegendeTabelle"><img src="img/matchingEdge.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Matching-Kante.</span></td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="LegendeMinimized">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                </div>
            </div>
            <div id="tf2_div_statusWindow" class="statusWindow">
                <h2>Versuche die Augmentationswege selbst zu finden</h2>
                <div id="tf2_div_abspielbuttons"></div>
                <!--                    <select id="tf2_select_aufgabeGraph" name="Wähle einen Graphen">
                                        <option selected>Selbsterstellter Graph</option>
                                        <option>Standardbeispiel</option>
                                    </select>-->
                <div id="tf2_div_statusErklaerung">
                    <!--                        <h3>Wähle zuerst den Graphen, mit dem du arbeiten möchtest.</h3>-->
                    <h3>Klicke auf den Button "Nächter Schritt", um mit der Forschungsaufgabe zu beginnen.</h3>
                    <p>Klicke auf die Knoten um einen Augmentationsweg einzuzeichnen. Klicke dabei in der Reihenfolge auf die Knoten, wie sie in dem Augmentationsweg vorkommen.</p>
                    <p>Mit einem Linksklick wählst du die Knoten aus und mit einem Rechtsklich kann du deine Wahl rückgängigmachen.</p>
                </div>

                <!--                <div id="tf2_div_legende">
                                        <p>Mit einem Linksklick wählst du die Knoten aus und mit einem Rechtsklich kann du deine Wahl rückgängigmachen.</p>
                                        <p>Klicke in der Reihenfolge auf die Knoten, wie sie in dem Augmentationsweg vorkommen.</p>
                                    </div>-->
                <!--                    <div id ="tf2_div_warning" class="ui-widget">
                                        <div class="ui-state-highlight ui-corner-all" style="padding: .7em;">
                                            <div class="ui-icon ui-icon-alert errorIcon"></div>
                                            <div id ="tf2_div_warning_text"></div>
                                        </div>
                                    </div>
                                    <div id ="tf2_div_status" class="ui-widget">

                                        &lt;!&ndash;<div class="ui-state-highlight ui-corner-all" style="padding: .7em;">
                                            <div class="ui-icon ui-icon-alert errorIcon"></div>
                                            <div id ="tf2_div_status_text"></div>
                                        </div>&ndash;&gt;
                                    </div>-->
            </div>
        </div>
        <div title="Forschungsaufgabe 2" class="tabIntroDialog">
            <h2>
                Versuche die Augmentationswege selbst zu finden.
            </h2>
            <p>Der Hopcroft-Karp-Algorithmus nutzt Augmentationswege, um ein maximales Matching zu finden.</p>
            <p>In dieser Aufgabe kannst du mit Augmentationspfaden selber experimentieren. Der Algorithmus stoppt an einigen Stellen, an denen du einen Augmentationspfad einzeichnen musst.
                Dabei ist es nicht notwendig den kürzesten Augmentationsweg einzuzeichnen. Du kannst selber entscheiden, welchen Augmentationsweg du nuzten möchtest.</p>
        </div>
        <div id="tf2_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
            <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
            <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
        </div>
    </div>
    <div id="tab_tw">
        <div id="tw_Accordion">
            <h3>Wie sieht der (Pseudo-)Code des Algorithmus aus?</h3>
            <div>
                <p>
                    <strong>Eingabe:</strong> Vollständiger gewichteter bipartiter Graph \(G=(V,E)\)<br />
                    <strong>Ausgabe:</strong> Bezüglich Kantengewichte optimales Matchin \(M \subseteq E\) als Liste von Kanten</p>
                <hr>
                <pre><code>BEGIN
    Initialisiere Markierungen
    WHILE Matching nicht optimal DO
        Finde freien Knoten als Wurzel eines alternierenden Pfades
        WHILE Pfad ist nicht augmentierend DO
            Konstruiere alternierenden Pfad in Gleichheitsgraph
            IF Kein alternierender Pfad gefunden THEN Verbessere Markierungen
        END
        Verbessere Matching
    END
END</code></pre>
            </div>

            <h3>Wie schnell ist der Algorithmus?</h3>
            <div>
                <h2>Geschwindigkeit von Algorithmen</h2>
                <p>Die Geschwindigkeit von Algorithmen wird üblicherweise in der <strong>Anzahl an Einzelschritten</strong> gemessen, die der Algorithmus bei der Ausführung benötigt.</p>
                <p>Einzelschritte sind beispielsweise:</p>
                <ul>
                  <li>Zuweisungen &ndash; Weise Knoten 1 den Wert 20 zu.</li>
                  <li>Vergleiche  &ndash; Ist 20 größer als 23?</li>
                  <li>Vergleich und Zuweisung  &ndash; Falls 20 größer als 15 ist, setze Variable <var>n</var> auf 20.</li>
                  <li>Einfache Arithmetische Operationen &ndash; Was ist 5 + 5 ?</li>
                </ul>
                <p>Da es sehr schwierig sein kann, diese Einzelschritte exakt zu zählen, möchte man nur die ungefähre <strong>Größenordnung</strong> der Anzahl Schritte wissen. Man spricht auch von der <strong>Laufzeit</strong> des Algorithmus. Meistens ist es besonders interessant, zu wissen, wie die Geschwindigkeit des Algorithmus von der Größe der Eingabe (hier: Anzahl Kanten und Knoten im Graph) abhängt.</p>
                <h2>Laufzeit der Ungarischen Methode</h2>
                <p>...</p>
            </div>

            <h3>Wie beweist man, dass der Algorithmus stets ein korrektes Ergebnis berechnet?</h3>
            <div>
                ...
            </div>

            <h3>Wo finde ich noch mehr Informationen zu Graphalgorithmen?</h3>
            <div>
                <p>Weitere Graphalgorithmen werden auf der <a href="http://www-m9.ma.tum.de/Allgemeines/GraphAlgorithmen">Webseite des Lehrstuhls M9</a> der TU München erklärt.</p>
                <p>Außerdem es ein interessantes Buch zu kürzesten Wegen: <a href="http://www-m9.ma.tum.de/Ruth/WebHome">Das Geheimnis des kürzesten Weges</a></p>
                <p>Ein <a href="http://www.ma.tum.de/Studium/Studieninteressierte">Mathematikstudium an der TU München</a> beantwortet alle Fragen zur Graphentheorie (falls eine Lösung bekannt ist).</p>
            </div>
        </div>
    </div>
</div>
<footer>
    <p class="Disclaimer">
        IDP Projekt von Mark J. Becker und Aleksejs Voroncovs am Lehrstuhl M9 der Technischen Universität München. <span id="year">2015</span> | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Disclaimer und Rechtshinweise</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">Impressum</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Anregungen</a>
    </p>
</footer>
</body>