<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="Diese Seite demonstriert die Ungarische Methode für maximale Matchings in bipartiten Graphen." />
    <meta http-equiv="X-UA-Compatible" content="IE=9">
    <meta name="author" content="Mark J. Becker, Aleksejs Voroncovs">
    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
    <link rel="stylesheet" type="text/css" href="../library/css/style.css" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <script src="../library/js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="../library/js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <script src="../library/js/lang.js" type="text/javascript"></script>
    <script src="js/utilities.js" type="text/javascript"></script>
    <script src="js/siteAnimation.js" type="text/javascript"></script>
    <script src="js/canvasDrawing.js" type="text/javascript"></script>
    <script src="js/graph.js" type="text/javascript"></script>
    <script src="js/algorithm.js" type="text/javascript"></script>
    <script src="js/textDB.js" type="text/javascript"></script>
    <script src="js/BipartiteGraph.js" type="text/javascript"></script>
    <script src="js/aufgabe1.js" type="text/javascript"></script>
    <script src="js/aufgabe2.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            showMathMenu: false,
            showMathMenuMSIE: false
        });
    </script>
    <script type="text/javascript" src="../library/js/mathjax/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=de"></script>

    <title>Die Ungarische Methode</title>
</head>
<body>
<noscript>
    <div class="ui-widget">
        <div class="ui-state-error ui-corner-all" style="padding: .7em;">
            <div class="ui-icon ui-icon-alert errorIcon"></div>
            <strong>Bitte aktivieren Sie Javascript!</strong>
            <ul style="margin: 0px;">
                <li>
                    Diese Seite benötigt Javascript, um ordnungsgemäß angezeigt zu werden.
                </li>
                <li>
                    In Ihrem Browser ist Javascript aktuell deaktiviert. Eine Anleitung zur Aktivierung von Javascript finden Sie beispielsweise <a href="http://www.enable-javascript.com/">hier</a>.
                </li>
            </ul>
        </div>
    </div>
</noscript>
<script>
    LNG.setLanguage('de');
    $(function() {
        initializeSiteLayout();
        $("#year").html(new Date().getFullYear());
    });
</script>
<header>
    <img src="img/titel.png" alt="Ungarische Methode">
    <img style="position:absolute; right:0px" src="../library/img/TUMLogo.png" alt="Technische Universität München">
</header>
<div id="tabs">
    <ul>
        <li><a href="#tab_te"><span>Einführung</span></a></li>
        <li><a href="#tab_tg"><span>Graph erstellen</span></a></li>
        <li><a href="#tab_ta"><span>Algorithmus ausführen</span></a></li>
        <li><a href="#tab_ti"><span>Beschreibung des Algorithmus</span></a></li>
        <li><a href="#tab_tf1"><span>Forschungsaufgabe 1</span></a></li>
        <li><a href="#tab_tf2"><span>Forschungsaufgabe 2</span></a></li>
        <li><a href="#tab_tw"><span>Weiteres</span></a></li>
    </ul>
    <div id="tab_te">
        <div id="te_div_Einfuehrungstext">
            <div id="te_div_beispiel1Container"><img id="te_img_beispiel1" src="img/beispiel1.png" alt="Bipartiter Graph mit Kantengewichten"><p>Wie sieht das optimale Matching aus?</p></div>
            <h1>Matchings optimalen Gewichts</h1>
            <p>Wir erweitern das das Beispiel einer Zuordnung von Studenten zu passenden Arbeitsstellen durch die Einführung einer Präferenz. Es wird nun eine Zuordnung gesucht, die möglichst die Präferenzen jeden Studenten erfüllt bzw. maximiert.</p>
            <p>In der Mathematik ist das Finden von Matchings zwischen Elementen unterschiedlicher Klassen ein häufig auftretendes Problem. In diesem Fall betrachten wir gewichtete Matchingprobleme, d.h. wir suchen Matchings mit optimalen Kantengewichten.</p>
            <h2>Die hier vorgestellte Ungarische Methode findet dann optimale Matchings in bipartiten Graphen.</h2>
            <div id ="te_div_Entscheidung">
                <h2>Was möchtest du zuerst tun?</h2>
                <button id="te_button_gotoDrawGraph">Den Algorithmus testen!</button>
                <button id="te_button_gotoIdee">Genauere Beschreibung des Algorithmus lesen</button>
            </div>
            <p></p>
            <br style="clear: both;" />
        </div>
    </div>
    <div id="tab_tg">
        <div>
            <div class="canvasWrapper">
                <canvas class="graphCanvas" id="tg_canvas_graph" width="700" height="500">
                    Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                </canvas>
                <div class="Legende" id="tg_div_Legende">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    <div class="LegendeText">
                        <table>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Knoten</span></td>
                            </tr>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Kante</span></td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="LegendeMinimized">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                </div>
            </div>
            <div id="tg_div_statusWindow" class="statusWindow">
                <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                <div id="tg_div_statusErklaerung">
                    <p>Um einen Knoten in einer Partition zu erstellen, mache einen Doppelklick in der Nähe dieser Partition. In diesem Graph kannst du maximal 8 Knoten in jeder Partition erstellen.</p>
                    <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
                    <p>Du kannst nur Kanten zwischen verschiedenen Partitionen einfügen. Um die Gewichte der Kanten zu ändern, klicke doppelt auf den mittleren Teil der Kante und gib den Gewichtswert ein.</p>
                    <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
                </div>
                <h3>Keine Lust, selbst einen Graph zu erstellen?<br></h3>
                <h3>Nimm ein fertiges Beispiel!<br></h3>
                <select id="tg_select_GraphSelector" name="Wähle einen Graphen">
                    <option selected id="tg_selectoption_empty">Selbsterstellter Graph</option>
                    <option>Zufallsgraph</option>
                    <option>Standardbeispiel</option>
                </select>
                <p><button id="tg_button_gotoAlgorithmTab">Fertig &ndash; weiter zum Algorithmus!</button></p>
            </div>
        </div>
        <div title="Graph erstellen" class="tabIntroDialog">
            <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
            <p>Um einen Knoten in einer Partition zu erstellen, mache einen Doppelklick in der Nähe dieser Partition. In diesem Graph kannst du maximal 8 Knoten in jeder Partition erstellen.</p>
            <p>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</p>
            <p>Du kannst nur Kanten zwischen verschiedenen Partitionen einfügen.</p>
            <p>Ein Rechtsklick löscht Kanten und Knoten.</p>
        </div>
    </div>
    <div id="tab_ta">
        <div>
            <div class="canvasWrapper">
                <canvas class="graphCanvas" id="ta_canvas_graph" width="700" height="500">
                    Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                </canvas>
                <div class="Legende">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    <div class="LegendeText">
                        <table>
                            <!--                                <tr>
                                                                <td class="LegendeTabelle"><img src="img/knoten.png" alt="Knoten" class="LegendeIcon"></td>
                                                                <td><span>Knoten</span></td>
                                                            </tr>-->
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingKnoten.png" alt="MatchedNode" class="LegendeIcon"></td>
                                <td><span>Matching-Knoten</span></td>
                            </tr>
                            <!--                                <tr>
                                                                <td class="LegendeTabelle"><img src="img/kante.png" alt="Knoten" class="LegendeIcon"></td>
                                                                <td><span>Kante</span></td>
                                                            </tr>-->
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingEdge.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Matching-Kante</span></td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="LegendeMinimized">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                </div>
            </div>
            <div id="ta_div_statusWindow" class="statusWindow">
                <h2 class="">Status des Algorithmus</h2>
                <div id="ta_div_abspielbuttons">
                </div>
                <div id="ta_div_statusTabs">
                    <ul>
                        <li><a href="#ta_div_statusErklaerung">Erklärung</a></li>
                        <li><a href="#ta_div_statusPseudocode">Pseudocode</a></li>
                    </ul>
                    <div id="ta_div_statusErklaerung">
                        <h3>Die Ungarische Methode</h3>
                        <p>Klicke auf <strong>Nächster Schritt</strong>, um den Algorithmus zu starten.</p>
                    </div>
                    <div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                        <p class="pseudocode" id="ta_p_l1">BEGIN</p>
                        <p class="pseudocode" id="ta_p_l2">  initialize labels</p>
                        <p class="pseudocode" id="ta_p_l3">  WHILE matching is not complete DO</p>
                        <p class="pseudocode" id="ta_p_l4">    find a root of an alternating path</p>
                        <p class="pseudocode" id="ta_p_l5">    WHILE alternating path not found DO</p>
                        <p class="pseudocode" id="ta_p_l6">      try to find alternating path</p>
                        <p class="pseudocode" id="ta_p_l7">      in equality graph</p>
                        <p class="pseudocode" id="ta_p_l8">      IF alt. path not found</p>
                        <p class="pseudocode" id="ta_p_l9">      THEN update labels</p>
                        <p class="pseudocode" id="ta_p_l10">    END</p>
                        <p class="pseudocode" id="ta_p_l11">    increase matching</p>
                        <p class="pseudocode" id="ta_p_l12">  END</p>
                        <p class="pseudocode" id="ta_p_l13">END</p>
                        <h3>Status der Variablen:</h3>
                        <table class="algoInformationen">
                            <tr>
                                <th class="algoInfoTH"><span>Matching</span></th>
                                <th class="algoInfoTH"><span>S</span></th>
                                <th class="algoInfoTH"><span>T</span></th>
                            </tr>
                            <tr>
                                <td id="ta_td_matching" class="algoInfoTD">&#8709;</td>
                                <td id="ta_td_setS" class="algoInfoTD">&#8709;</td>
                                <td id="ta_td_setT" class="algoInfoTD">&#8709;</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div title="Algorithmus ausführen" class="tabIntroDialog">
            <h2>Die Ungarische Methode ausführen</h2>
            <p>In diesem Schritt sehen wir, wie der Algorithmus arbeitet.</p>
            <p>Rechts vom Graph kannst du die Ausführung kontrollieren.</p>
        </div>
        <div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
            <h2>Beim Wechsel des Tabs wird der Algorithmus abgebrochen.</h2>
            <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
        </div>
    </div>
    <div id="tab_ti">
        <div id="ti_div_Einfuehrungstext">
            <div class="BeispielbildContainer">
                <img id="ti_img_beispiel1" src="img/beispiel_optimal.png" alt="Optimales Matching" /><p>Bild 1: Ein optimales Matching (grün)</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_markierungen.png" alt="Markierungen" /><p>Bild 2: Knotenmarkierungen</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_gleichheitsgraph.png" alt="Gleichheitsgraph" /><p>Bild 3: Gleichheitsgraph</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_frei.png" alt="Matched / Frei" /><p>Bild 4: Freie (a,f) und Matched Knoten (b,c,d,e)</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_alternierend.png" alt="Alternierender Pfad" /><p>Bild 5: Ein alternierender Pfad (f,e,d)</p><br />
                <img id="ti_img_beispiel1" src="img/beispiel_augment.png" alt="Augmentierender Pfad" /><p>Bild 6: Ein augmentierender Pfad (f,e,d,c,b,a)</p>
            </div>
            <h1>Das Finden von optimalen Matchings</h1>

            <p>Im Alltag kann man viele Zuordnungsprobleme finden, die mittels Matchings auf bipartiten Graphen modelliert werden könnnen. Hier möchten wir uns speziell mit gewichteten Zuordnungsproblemen beschäftigen.</p>
            <p>Als Beispiel betrachten wir folgende Problemstellung: Ein Unternehmer hat in seinem Betrieb eine Menge von Aufgaben, die bearbeitet werden müssen. Seine Mitarbeiter sind aufgrund verschiedener Qualifikationen aber nicht alle gleichermaßen für jede Aufgabe geeignet. Das bedeutet, dass alle Mitarbeiter bei der Bearbeitung der Aufgaben jeweils unterschiedliche Effizienzsgrade aufweisen. Weil der Unternehmer möglichst effizient wirtschaften möchte, muss er die Aufgaben so verteilen, dass der Effizienzgrad pro Aufgabe möglichst maximal ist.</p>
            <p>Wir können dieses Problem als bipartiten Graphen mit Knotenmengen \(X\) (<strong style="color: orange;">orange</strong>) für die Mitarbeiter und \(Y\) (<strong style="color: red;">rot</strong>) für die Aufgaben darstellen (vgl. Bild 1). In folgenden Darstellungen werden wir die Knotenmengen nicht erneut kennzeichnen. Die gewichteten Kanten zwischen den Mengen definieren dann die Anzahl der Stunden, die ein Mitarbeiter \(x\) für Aufgabe \(y\) benötigt. Jetzt gilt es ein perfektes Matching zu finden, bei dem die Summe aller Kantengewichte maximal ist.</p>
            <p>&nbsp;</p>
            
            <h1>Die Ungarische Methode</h1>
            <p>Das Problem kann mittels der Ungarischen Methode gelöst werden, die 1955 von Harold W. Kuhn auf Grundlage der Ideen zweier ungarische Mathematiker (Dénes Kőnig und Jenő Egerváry) entwickelt wurde. Der Algorithmus wurde später von James Munkres verbessert und basiert auf einem zentralen Theorem für dessen Verständnis wir aber ein paar Begriffe benötigen:</p>

            <p><strong>Markierung</strong><br />
            Wir führen eine einfache Hilfsfunktion oder Markierung \(l\) ein, die jedem Knoten im Graph eine reelle Zahl so zuordnet, dass die Summe der Markierungen zweier Knoten mindestens so groß ist, wie das Kantengewicht \(w\) der Kante, die diese Knoten verbindet (vgl. Bild 2).</p>
            <p style="text-align: center;">\(l(x) + l(y) \ge w(x, y)\)</p>

            <p><strong>Gleichheitsgraph</strong><br />
            Mittels der Markierungen können wir einen Gleichheitsgraph \(G_l = (V, E_l)\) definieren der alle Knoten aus unserem Ausgangsgraph besitzt. Die Kantenmenge enthält jedoch nur die Kanten, deren Gewicht genau der Summe der Markierungen ihrer Knoten entspricht (vgl. Bild 3).</p>
            <p style="text-align: center;">\(E_l = \{(x,y) \in E\ |\ l(x) + l(y) = w(x, y)\}\)</p>

            <p>Nun zu dem oben angesprochenem Theorem. Das Kuhn-Munkres-Theorem besagt, dass wenn man ein perfektes Matching im Gleichheitsgraph findet, dieses im Ausgangsgraph maximal ist. Das Problem des optimalen Matchings kann man damit also auf das Finden eines perfekten Matchings im Gleichheitsgraph reduzieren.</p>

            <p>Bevor wir nun zum eigentlichen Algorithmus kommen, hier noch ein paar Hinweise:</p>

            <p>Die Ungarische Methode in der hier beschriebenen Form findet maximale Matchings, also Matchings mit möglichst hohen Kantengewichten. Das bedeutet, dass wir das zu Beginn geschilderte Problem umformen müssen. Dazu kann man die Kantengewichte durch einen Vorzeichenwechsel "spiegeln", d.h. aus \(w(x,y)\) macht man \(-w(x,y)\).</p>

            <p>Außerdem muss der bipartite Graph, auf den wir den Algorithmus anwenden vollständig sein. Das heißt, es muss gleich viele Knoten in \(X\) und \(Y\) geben und von jedem Knoten einer Partition müssen Kanten zu jedem Knoten der anderen Partition führen. In unserem Beispiel wäre dies nicht der Fall, wenn ein Mitarbeiter eine Aufgabe gar nicht bearbeiten kann. In diesem Fall fügt man neutrale Knoten und Kanten mit Kantengewicht \(0\) ein, sodass der Graph vollständig wird. Sofern die hinzugefügten neutralen Elemente nach Ausführung des Algorithmus im gefundenen Matching enthalten sind, kann man sie einfach wieder entfernen.</p>
            <p>&nbsp;</p>

            <h1>Der Ablauf des Algorithmus</h1>

            <p>Das Finden eines perfekten Matchings im Gleichheitsgraph geschieht schrittweise. Der Algorithmus beginnt mit einem leeren Matching und versucht dieses in jedem Schritt zu verbessern, bis es perfekt ist.</p>

            <p>Zu Beginn bestimmt der Algorithmus für alle Knoten eine Markierung. Die Markierung eines Knoten aus \(X\) entspricht dem Gewicht seiner größten Kante und \(0\) für einen Knoten aus \(Y\). Mittels der Markierungen bestimmt der Algorithmus dann einen Gleichheitsgraph. Für den weiteren Ablauf definieren wir zunächst weitere Begriffe:</p>

            <p><strong>Alternierende und augmentierende Pfade</strong><br />
            Wir sagen, ein Knoten wurde gematcht, wenn er eine Kante besitzt, die im aktuellen Matching enthalten ist. Ansonsten nennen wir ihn frei (vgl. Bild 4).<br />
            Ein alternierender Pfad ist eine Abfolge von Kanten, bei dem die Kanten abwechselnd im Matching \(M\) enthalten und nicht enthalten \(E \setminus M\) sind (vgl. Bild 5).<br />Ein alternierender Pfad ist zusätzlich augmentierend, wenn Anfangs- und Endknoten beide frei sind (vgl. Bild 6).</p>

            <p>Um das bestehende noch leere Matching zu verbessern, sucht sich der Algorithmus einen Knoten aus \(X\), der noch keinen Matchingpartner besitzt. Ausgehend von diesem, versucht der Algorithmus einen augmentierenden Pfad zu finden. Dazu baut der Algorithmus schrittweise einen alternierenden Pfad, solange bis dieser augmentierend wird oder es keine weitere Kante mehr gibt. Die dabei besuchten Knoten teilen wir in die Mengen \(S\) für besuchte Knoten aus \(X\) und die Menge \(T\) für besuchte Knoten aus \(Y\) ein.</p>

            <p>Es lässt sich nicht immer ein augmentierender Pfad finden. Dann muss der Algorithmus die Markierungen verbessern. Die Verbesserung muss so erfolgen, dass das aktuelle Matching im Gleichheitsgraph enthalten bleibt. Außerdem muss der Gleichheitsgraph durch neue Kanten so erweitert werden, dass ein neuer alternierender Pfad konstruiert werden kann. Dies geschieht, indem zunächst ein \(\Delta\) bestimmt wird. Der Algorithmus betrachtet alle Paare aus besuchten Knoten \(s \in S\) und unbesuchten Knoten \(y \in Y \setminus T\) und bildet das Minimum aus der Summe ihrer Markierungen abzüglich des Gewichts der Kante zwischen beiden Knoten.</p>

            <p style="text-align: center;">\(\Delta = \min\limits_{s \in S\ \wedge\ y \in Y \setminus T}\{l(s) + l(y) - w(s,y)\}\)</p>

            <p>Mittels \(\Delta\) kann man nun die Markierungen aller Knoten anpassen. Danach bestimmt der Algorithmus einen neuen Gleichheitsgraph und sucht erneut nach einem augmentierenden Pfad.</p>

            <p style="text-align: center;">
            \(\begin{equation}
               l^\prime(v) =
               \begin{cases}
                 l(v) - \Delta & v \in S\\
                 l(v) + \Delta & v \in T \\
                 l(v) & sonst
               \end{cases}
            \end{equation}\)
            </p>

            <p>Wenn der Algorithmus einen augmentierenden Pfad findet, verbessert er das Matching, indem er die Kanten des Pfades, die nicht in dem Matching enthalten sind, dem Matching hinzufügt und die Kanten des Pfades, die im Matching enthalten sind, entfernt. Dieses Vorgehen wird wiederholt, bis jeder Knoten einen Matchingpartner hat und das Matching so perfekt ist. Nach dem o.g. Theorem ist das bestimmte Matching dann bezüglich der Kantengewichte ein maximales Matching.</p>
            <p>&nbsp;</p>

            <h1>Was nun?</h1>
            <br style="clear: both;" />
            <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                <h3>Einen Graph erstellen und den Algorithmus durchspielen</h3>
                <button id="ti_button_gotoDrawGraph">Graph erstellen und daran den Algorithmus testen</button>
                <button id="ti_button_gotoAlgorithm">Algorithmus am fertigen Beispiel ausprobieren</button>
            </div>
            <div class="Entscheidungsweg" id="ti_div_EntscheidungRight">
                <h3>Sein Wissen an den Forschungsaufgaben testen</h3>
                <button id="ti_button_gotoFA1">Forschungsaufgabe: Wie würde der Algorithmus entscheiden?</button>
                <button id="ti_button_gotoFA2">Forschungsaufgabe: Augmentationswege und Gleichheitsgraphen</button>
            </div>
            <br style="clear: both;" />
        </div>
    </div>
    <div id="tab_tf1">
        <div>
            <div class="canvasWrapper">
                <canvas class="graphCanvas" id="tf1_canvas_graph" width="700" height="500">
                    Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                </canvas>
                <div class="Legende">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    <div class="LegendeText">
                        <table>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingKnoten.png" alt="MatchedNode" class="LegendeIcon"></td>
                                <td><span>Matching-Knoten</span></td>
                            </tr>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingEdge.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Matching-Kante</span></td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="LegendeMinimized">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                </div>
            </div>
            <div id="tf1_div_statusWindow" class="statusWindow">
                <h2 class="">Prüfe dein Wissen: Wie würde der Algorithmus entscheiden?</h2>
                <div id="tf1_div_abspielbuttons">
                </div>
                <div id="tf1_div_questionModal" class="ui-widget ui-widget-content ui-corner-all" style="display: none;">
                </div>
                <div id="tf1_div_statusTabs">
                    <ul>
                        <li><a href="#tf1_div_statusErklaerung">Erklärung</a></li>
                        <li><a href="#tf1_div_statusPseudocode">Pseudocode</a></li>
                    </ul>
                    <div id="tf1_div_statusErklaerung">
                        <h3>Die Ungarische Methode</h3>
                        <p>Bei dieser Aufgabe kannst du zeigen, wie gut du den Algorithmus verstanden hast. Erstelle dir einen beliebigen Graphen und starte den Algorithmus. An manchen Stellen wird der Algorithmus stoppen und dann bist du gefragt.</p>
                        <p>Du wirst verschiedene Fragen zum Ablauf des Algorithmus bekommen. Am Ende bekommst du dann eine Auswertung, die dir zeigt, wie gut du abgeschnitten hast.</p>
                        <p>Klicke auf <strong>Nächster Schritt</strong> um den Algorithmus zu starten. Viel Erfolg!</p>
                    </div>
                    <div class="PseudocodeWrapper" id="tf1_div_statusPseudocode">
                        <p class="pseudocode" id="tf1_p_l1">BEGIN</p>
                        <p class="pseudocode" id="tf1_p_l2">  initialize labels</p>
                        <p class="pseudocode" id="tf1_p_l3">  WHILE matching is not complete DO</p>
                        <p class="pseudocode" id="tf1_p_l4">    find a root of an alternating path</p>
                        <p class="pseudocode" id="tf1_p_l5">    WHILE alternating path not found DO</p>
                        <p class="pseudocode" id="tf1_p_l6">      try to find alternating path</p>
                        <p class="pseudocode" id="tf1_p_l7">      in equality graph</p>
                        <p class="pseudocode" id="tf1_p_l8">      IF alt. path not found</p>
                        <p class="pseudocode" id="tf1_p_l9">      THEN update labels</p>
                        <p class="pseudocode" id="tf1_p_l10">    END</p>
                        <p class="pseudocode" id="tf1_p_l11">    increase matching</p>
                        <p class="pseudocode" id="tf1_p_l12">  END</p>
                        <p class="pseudocode" id="tf1_p_l13">END</p>
                        <h3>Status der Variablen:</h3>
                        <table class="algoInformationen">
                            <tr>
                                <th class="algoInfoTH"><span>Matching</span></th>
                                <th class="algoInfoTH"><span>S</span></th>
                                <th class="algoInfoTH"><span>T</span></th>
                            </tr>
                            <tr>
                                <td id="tf1_td_matching" class="algoInfoTD">&#8709;</td>
                                <td id="tf1_td_setS" class="algoInfoTD">&#8709;</td>
                                <td id="tf1_td_setT" class="algoInfoTD">&#8709;</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div id="tf1_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
            <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
            <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex="-1">in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
        </div>
    </div>
    <div id="tab_tf2">
        <div>
            <div class="canvasWrapper">
                <canvas class="graphCanvas" id="tf2_canvas_graph" width="700" height="500">
                    Ihr Browser unterstützt kein HTML5 Canvas. Bitte verwenden Sie einen modernen Browser, z.B.<a href="http://www.mozilla.org/de/firefox">Mozilla Firefox</a>
                </canvas>
                <div class="Legende">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    <div class="LegendeText">
                        <table>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingKnoten.png" alt="MatchedNode" class="LegendeIcon"></td>
                                <td><span>Matching-Knoten</span></td>
                            </tr>
                            <tr>
                                <td class="LegendeTabelle"><img src="img/matchingEdge.png" alt="Knoten" class="LegendeIcon"></td>
                                <td><span>Matching-Kante</span></td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="LegendeMinimized">
                    <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                </div>
            </div>
            <div id="tf2_div_statusWindow" class="statusWindow">
                <h2 class="">Prüfe dein Wissen: Wie würde der Algorithmus entscheiden?</h2>
                <div id="tf2_div_abspielbuttons">
                </div>
                <div id="tf2_div_questionModal" class="ui-widget ui-widget-content ui-corner-all" style="display: none;">
                </div>
                <div id="tf2_div_statusTabs">
                    <ul>
                        <li><a href="#tf2_div_statusErklaerung">Erklärung</a></li>
                        <li><a href="#tf2_div_statusPseudocode">Pseudocode</a></li>
                    </ul>
                    <div id="tf2_div_statusErklaerung">
                        <h3>Die Ungarische Methode</h3>
                        <p>Bei dieser Aufgabe kannst du zeigen, wie gut du den Algorithmus verstanden hast. Die Ungarische Methode wird auf dem bestimmten Graphen ausgeführt. An manchen Stellen wird der Algorithmus stoppen und dann bist du gefragt.</p>
                        <p>Du wirst verschiedene Fragen zum Ablauf des Algorithmus bekommen. Am Ende bekommst du dann eine Auswertung, die dir zeigt, wie gut du abgeschnitten hast.</p>
                        <p>Klicke auf <strong>Nächster Schritt</strong> um den Algorithmus zu starten. Viel Erfolg!</p>
                    </div>
                    <div class="PseudocodeWrapper" id="tf2_div_statusPseudocode">
                        <p class="pseudocode" id="tf2_p_l1">BEGIN</p>
                        <p class="pseudocode" id="tf2_p_l2">  initialize labels</p>
                        <p class="pseudocode" id="tf2_p_l3">  WHILE matching is not complete DO</p>
                        <p class="pseudocode" id="tf2_p_l4">    find a root of an alternating path</p>
                        <p class="pseudocode" id="tf2_p_l5">    WHILE alternating path not found DO</p>
                        <p class="pseudocode" id="tf2_p_l6">      try to find alternating path</p>
                        <p class="pseudocode" id="tf2_p_l7">      in equality graph</p>
                        <p class="pseudocode" id="tf2_p_l8">      IF alt. path not found</p>
                        <p class="pseudocode" id="tf2_p_l9">      THEN update labels</p>
                        <p class="pseudocode" id="tf2_p_l10">    END</p>
                        <p class="pseudocode" id="tf2_p_l11">    increase matching</p>
                        <p class="pseudocode" id="tf2_p_l12">  END</p>
                        <p class="pseudocode" id="tf2_p_l13">END</p>
                        <h3>Status der Variablen:</h3>
                        <table class="algoInformationen">
                            <tr>
                                <th class="algoInfoTH"><span>Matching</span></th>
                                <th class="algoInfoTH"><span>S</span></th>
                                <th class="algoInfoTH"><span>T</span></th>
                            </tr>
                            <tr>
                                <td id="tf2_td_matching" class="algoInfoTD">&#8709;</td>
                                <td id="tf2_td_setS" class="algoInfoTD">&#8709;</td>
                                <td id="tf2_td_setT" class="algoInfoTD">&#8709;</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div id="tf2_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">
            <h2>Beim Wechsel des Tabs wird die Aufgabe abgebrochen.</h2>
            <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex="-1">in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
        </div>
    </div>
    <div id="tab_tw">
        <div id="tw_Accordion">
            <h3>Wie sieht der (Pseudo-)Code des Algorithmus aus?</h3>
            <div>
                <p>
                    <strong>Eingabe:</strong> Vollständiger gewichteter bipartiter Graph \(G=(V,E)\)<br />
                    <strong>Ausgabe:</strong> Bezüglich Kantengewichte optimales Matchin \(M \subseteq E\) als Liste von Kanten</p>
                <hr>
                <pre><code>BEGIN
    Initialisiere Markierungen
    Konstruiere Gleichheitsgraph
    WHILE Matching nicht optimal DO
        Finde freien Knoten als Wurzel eines alternierenden Pfades
        WHILE Pfad ist nicht augmentierend DO
            Konstruiere alternierenden Pfad in Gleichheitsgraph
            IF Kein alternierender Pfad gefunden 
            THEN Verbessere Markierungen und konstruiere neuen Gleichheitsgraph
        END
        Verbessere Matching
    END
END</code></pre>
            </div>

            <h3>Wie schnell ist der Algorithmus?</h3>
            <div>
                <h2>Geschwindigkeit von Algorithmen</h2>
                <p>Die Geschwindigkeit von Algorithmen wird üblicherweise in der <strong>Anzahl an Einzelschritten</strong> gemessen, die der Algorithmus bei der Ausführung benötigt.</p>
                <p>Einzelschritte sind beispielsweise:</p>
                <ul>
                  <li>Zuweisungen &ndash; Weise Knoten 1 den Wert 20 zu.</li>
                  <li>Vergleiche  &ndash; Ist 20 größer als 23?</li>
                  <li>Vergleich und Zuweisung  &ndash; Falls 20 größer als 15 ist, setze Variable <var>n</var> auf 20.</li>
                  <li>Einfache Arithmetische Operationen &ndash; Was ist 5 + 5 ?</li>
                </ul>
                <p>Da es sehr schwierig sein kann, diese Einzelschritte exakt zu zählen, möchte man nur die ungefähre <strong>Größenordnung</strong> der Anzahl Schritte wissen. Man spricht auch von der <strong>Laufzeit</strong> des Algorithmus. Meistens ist es besonders interessant, zu wissen, wie die Geschwindigkeit des Algorithmus von der Größe der Eingabe (hier: Anzahl Kanten und Knoten im Graph) abhängt.</p>
                <h2>Laufzeit der Ungarischen Methode</h2>
                <p>Zur Implementierung der Ungarischen Methode gibt es mehrere Varianten, die sich in ihrer Laufzeit unterscheiden. Wir betrachten hier die Variante mit der kürzesten Laufzeit.</p>
                <p>Dazu gehen wir von einem vollständig bipartitem Graphen \(G = (V, E)\) mit \(V = X \cup Y \land X \cap Y = \emptyset\) und einem leeren initialen Matching \(M\) aus. Zur Komplexitätsbestimmung definieren wir außerdem \(|V| = n, |X| = n_1, |Y| = n_2\).</p>
                <p>Zu Beginn wird der Graph mit neutralen Kanten ergänzt und es wird ein initales Matching bestimmt. Dazu müssen alle Kanten betrachtet werden. In vollständigen bipartien Graphen sind das \(O(n_1 * n_2)\).</p>
                <p>Der Algorithmus versucht dann, in jedem Durchgang das Matching um einen Knoten zu ergänzen, d.h. er benötigt maximal \(n\) Durchgänge. Pro Durchgang werden mehrere Berechnungen durchgeführt:</p>
                <ul>
                    <li>Zur Bestimmung des Gleichheitsgraphs müssen ebenfalls alle Kanten betrachtet werden: \(O(n_1 * n_2)\).</li>
                    <li>Das Finden einer neuen Wurzel benötigt im schlechtesten Fall \(O(n)\).</li>
                    <li>Zur Konstruktion eines augmentierenden Pfades werden von der Wurzel ausgehend alle Kanten des Gleichheitsgraphs betrachtet. Dieser enthält im ungünstigsten Fall alle Kanten. Das heißt man erhält hier wieder eine Komplexität von \(O(n_1 * n_2)\).</li>
                    <li>Der augmentierende Pfad beseitzt maximal die Länge \(n\). Daher benötigt das anschließende Austauschen der Kanten zum verbessern des Matchings \(O(n)\) Schritte.</li>
                    <li>Die Überprüfung, ob das gefundene Matching perfekt ist, kann durch einen einfachen Vergleich der Anzahl der Kanten bewerkstelligt werden: \(O(1)\).</li>
                </ul>
                <p>Die signifikateste Berechnung tritt auf, wenn kein augmentierender Pfad gefunden werden kann. Dann muss ein neuer Gleichheitsgraphs durch Anpassung der Markierungen und Berechnung eines Deltas \(\Delta\) bestimmt werden. Durch die Bestimmung eines neuen Gleichheitsgraph besteht jedoch keine Garantie, dass ein augmentierender Pfad konstruiert werden kann. Ingesamt können dem Gleichheitsgraph durch Verbesserungen der Markierungen aber nur \(O(n)\) Kanten hinzugefügt werden. Dieser Vorgang besitzt bei trivialer Implementierung eine Laufzeit von \(O(n^4)\). Durch geschicktes Zwischenspeichern einzelner Werte kann die Berechnung des Deltas aber auf \(O(n^2)\) reduziert werden.</p>
                <p>Insgesamt besitzt der Algorithmus damit eine kubische Laufzeit von \(O(n^3)\).</p>
            </div>

            <h3>Wie beweist man, dass der Algorithmus stets ein korrektes Ergebnis berechnet?</h3>
            <div>
                <p>Maßgeblich für die Korrektheit des Algorithmus ist das Kuhn-Munkres-Theorem. Es besagt, dass perfekte Matchings in einem Gleichheitsgraph im Ursprungsgraph optimal sind, d.h. maximales Gewicht haben.</p>
                <h2>Formaler Beweis</h2>
                <p>Wir gehen von zulässigen Markierungen \(l: V \to \mathbb{R}\), einem beliebigen perfekten Matching \(M' \subseteq E\) und einem optimalen Matching \(M \subseteq E\) mit maximalem Gewicht \(w(M)\) aus.</p>
                <p>
                \( 
                    \begin{align}
                        w(M') 
                        &= \sum\limits_{(x,y) \in M'} w(x,y)                &&\text{(Gesamtgewicht ist gleich der Summe der Kantengewichte)}
                        \\ &\le \sum\limits_{(x,y) \in M'} (l(x) + l(y))    &&\text{(Einsetzen der Markierungs Formel)}
                        \\ &= \sum\limits_{v \in V} l(v)                    &&\text{(Da M' perfekt, ist jede Markierung genau einmal in der Summe enthalten)}
                        \\ &= \sum\limits_{(x,y) \in M} (l(x) + l(y))       &&\text{(Da M auch perfekt, gilt das gleiche)}
                        \\ &= \sum\limits_{(x,y) \in M} w(x,y)             &&\text{(Alle Kanten aus M sind im Gleichheitsgraph enthalten)}
                        \\ &= w(M)                                          && \square
                    \end{align}
                \)
                </p>
            </div>

            <h3>Wo finde ich noch mehr Informationen zu Graphalgorithmen?</h3>
            <div>
                <p>Weitere Graphalgorithmen werden auf der <a href="http://www-m9.ma.tum.de/Allgemeines/GraphAlgorithmen">Webseite des Lehrstuhls M9</a> der TU München erklärt.</p>
                <p>Außerdem es ein interessantes Buch zu kürzesten Wegen: <a href="http://www-m9.ma.tum.de/Ruth/WebHome">Das Geheimnis des kürzesten Weges</a></p>
                <p>Ein <a href="http://www.ma.tum.de/Studium/Studieninteressierte">Mathematikstudium an der TU München</a> beantwortet alle Fragen zur Graphentheorie (falls eine Lösung bekannt ist).</p>
            </div>
        </div>
    </div>
</div>
<footer>
    <p class="Disclaimer">
        IDP Projekt von Mark J. Becker und Aleksejs Voroncovs am Lehrstuhl M9 der Technischen Universität München. <span id="year">2015</span> | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Disclaimer und Rechtshinweise</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">Impressum</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Anregungen</a>
    </p>
</footer>
</body>